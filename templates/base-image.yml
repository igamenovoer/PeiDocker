version: '3'

x-cfg-stage-1:

  # ./installation will be copied to /init-me in the container
  # all paths specified in cfg are the in-container paths
  paths:
    _root_dir_host: ./installation/stage-1
    _root_dir_container: /init-me/stage-1

  build:
    # built image name and tag
    output_image_name: my_image
    output_image_tag: stage-1

    # base image
    # base_image: nvidia/cuda:12.3.2-base-ubuntu22.04
    base_image: ubuntu:22.04
    root_password: ''

    apps:
      # install essential apps, by executing /init-me/stage-1/internals/install-essential-apps.sh
      with_essential_apps: true

      # install additional apps, by executing /init-me/stage-1/custom/custom-install-apps.sh
      with_comstom_apps: true

    # ssh configurations
    ssh:
      with_ssh: true
      username: me
      password: 123456
      port : 22 # ssh port in container

      # ssh public key file, if not set, password will be used
      # if you want to use your own key, copy the key to system/ssh/keys and set the file name here, like this
      # pubkey_file: /init-me/stage-1/system/ssh/keys/mykey.rsa.pub
      pubkey_file: ''

    proxy:
      # proxy configurations, the proxy will be exposed in the container
      # and you can optionally use it for apt, shell, or custom scripts
      proxy_port: 7890
      proxy_address: host.docker.internal

      # deduced http proxy settings, you do not have to touch this
      _proxy_http: http://${.proxy_address}:${.proxy_port}
      _proxy_https: http://${.proxy_address}:${.proxy_port}

    # apt settings
    apt:
      # replace apt source file?
      # use empty string to retain the default source file
      # source_file: ''
      source_file: '/init-me/stage-1/system/apt/ubuntu-22.04-x86_64.list'
      keep_source_file: true  # retain apt source file after build? If false, source file will be removed after build

      # use http proxy for apt? 
      use_proxy: false # use proxy for apt install ?
      keep_proxy: false # retain http proxy settings in apt after build? If false, proxy will be removed after build
  run: &stage-1-run
    ssh:
      host_port: 12222
    device: cpu  # can be gpu, cpu, mps
    environment: {}

x-cfg-stage-2:
  paths:
    _root_dir_host: ./installation/stage-2
    _root_dir_container: /init-me/stage-2

    # in-container paths
    _hard_apps: /hard/volume/apps
    _hard_data: /hard/volume/data
    _hard_workspace: /hard/volume/workspace

  build:
    output_image_name: my_image
    output_image_tag: stage-2
    base_image: my_image:stage-1

    apps:
      with_essential_apps: true
      with_comstom_apps: true

  run:
    <<: *stage-1-run

  storage:
    # storage type can be auto-volume, external-volume, host, image
    # auto-volume: automatically created volumes by docker compose, you need to remove them manually
    # external-volume: external volumes manually created using "docker volume create", you have to set the names in external_volume_names
    # host: directories in host that will be mounted to the container, you have set the paths in host_dirs
    # image: in-image storage, nothing to mount
    type: image 

    # directories in host that will be mounted to the container
    host_dirs: 
      apps: null   # to be mounted to /hard/volume/app
      data: null   # to be mounted to /hard/volume/data
      workspace: null  # to be mounted to /hard/volume/workspace

    # external volumes created using docker volume create
    # you must explicitly create these volumes and write the names here
    external_volume_names:
      apps: null   # to be mounted to /hard/volume/app
      data: null # to be mounted to /hard/volume/data
      workspace: null  # to be mounted to /hard/volume/workspace
        
x-sections:
  run-with-device:
    # use in deploy.resources.reservations.devices
    gpu:
      - driver: nvidia
        capabilities: [gpu]
    cpu:  []
    mps:  []

  mount:
    # automatically created volumes by docker compose, you need to remove them manually
    auto-volume:
      # append to docker compose volume section
      volumes:
        app:
        data:
        workspace:

      # append to docker compose services section
      runtime-mount:
        - "app:${x-cfg-stage-2.paths._hard_apps}"
        - "data:${x-cfg-stage-2.paths._hard_data}"
        - "workspace:${x-cfg-stage-2.paths._hard_workspace}"
    
    external-volume:
      # append to docker compose volume section
      volumes:
        app:
          external: true
          name: ${x-cfg-stage-2.storage.external_volume_names.apps}
        data:
          external: true
          name: ${x-cfg-stage-2.storage.external_volume_names.data}
        workspace:
          external: true
          name: ${x-cfg-stage-2.storage.external_volume_names.workspace}
      runtime-mount:
        - "app:${x-cfg-stage-2.paths._hard_apps}"
        - "data:${x-cfg-stage-2.paths._hard_data}"
        - "workspace:${x-cfg-stage-2.paths._hard_workspace}"

    host:
      # append to docker compose volume section
      volumes: {}
      runtime-mount:
        - "${x-cfg-stage-2.storage.host_dirs.apps}:${x-cfg-stage-2.paths._hard_apps}"
        - "${x-cfg-stage-2.storage.host_dirs.data}:${x-cfg-stage-2.paths._hard_data}"
        - "${x-cfg-stage-2.storage.host_dirs.workspace}:${x-cfg-stage-2.paths._hard_workspace}"
    
    image:
      # in-image storage, nothing to mount
      volumes: {}
      runtime-mount: []

services:
  stage_2:
    image: ${x-cfg-stage-2.build.output_image_name}:${x-cfg-stage-2.build.output_image_tag}

    # automatic start bash in ssh
    stdin_open: true
    tty: true
    command: /bin/bash

    # port mapping
    ports:
      - "${x-cfg-stage-2.run.ssh.host_port}:${x-cfg-stage-1.build.ssh.port}"
    
    # use gpu?
    deploy:
      resources:
        reservations:
          devices: ${x-sections.run-with-device[${x-cfg-stage-2.run.device}]}

    # required to use proxy
    extra_hosts:
      - "host.docker.internal:host-gateway"

    # mount volumes
    volumes: ${x-sections.mount[${x-cfg-stage-2.storage.type}].runtime-mount}

    build:
      context: .
      dockerfile: stage_2.Dockerfile

      # required to use proxy
      extra_hosts:
        - "host.docker.internal:host-gateway"

      args:
        BASE_IMAGE: ${x-cfg-stage-2.build.base_image}

        # install essential apps, by executing /installation/scripts/install-essential-apps.sh
        WITH_ESSENTIAL_APPS: ${x-cfg-stage-2.build.apps.with_essential_apps}

        # install additional apps, by executing /installation/custom-scripts/custom-install-apps.sh
        WITH_CUSTOM_APPS: ${x-cfg-stage-2.build.apps.with_comstom_apps}

        # installation dirs
        INSTALL_DIR_HOST_2: ${x-cfg-stage-2.paths._root_dir_host}
        INSTALL_DIR_CONTAINER_2: ${x-cfg-stage-2.paths._root_dir_container}

  stage_1:
    image: ${x-cfg-stage-1.build.output_image_name}:${x-cfg-stage-1.build.output_image_tag}

    # automatic start bash in ssh
    stdin_open: true
    tty: true
    command: /bin/bash

    # port mapping
    ports:
      - "${x-cfg-stage-1.run.ssh.host_port}:${x-cfg-stage-1.build.ssh.port}"

    # use gpu?
    deploy:
      resources:
        reservations:
          devices: ${x-sections.run-with-device[${x-cfg-stage-1.run.device}]}

    # user provided environments
    environment: ${x-cfg-stage-1.run.environment}

    # required to use proxy
    extra_hosts:
      - "host.docker.internal:host-gateway"

    build:
      context: .
      dockerfile: stage_1.Dockerfile

      # required to use proxy
      extra_hosts:
        - "host.docker.internal:host-gateway"

      args:
        BASE_IMAGE: ${x-cfg-stage-1.build.base_image}

        # install essential apps, by executing /installation/scripts/install-essential-apps.sh
        WITH_ESSENTIAL_APPS: ${x-cfg-stage-1.build.apps.with_essential_apps}

        # install additional apps, by executing /installation/custom-scripts/custom-install-apps.sh
        WITH_CUSTOM_APPS: ${x-cfg-stage-1.build.apps.with_comstom_apps}

        # install openssh-server, and set up ssh user, password, public key (optional)
        WITH_SSH: ${x-cfg-stage-1.build.ssh.with_ssh}
        SSH_USER_NAME: ${x-cfg-stage-1.build.ssh.username} # default ssh user name
        SSH_USER_PASSWORD: ${x-cfg-stage-1.build.ssh.password}  # default ssh user password
        SSH_PUBKEY_FILE: ${x-cfg-stage-1.build.ssh.pubkey_file} # ssh public key file, if not set, password will be used

        # replace apt source file?
        APT_SOURCE_FILE: ${x-cfg-stage-1.build.apt.source_file}
        KEEP_APT_SOURCE_FILE: ${x-cfg-stage-1.build.apt.keep_source_file}  # retain apt source file after build? If false, source file will be removed after build
        APT_USE_PROXY: ${x-cfg-stage-1.build.apt.use_proxy} # use proxy for apt install ?
        APT_KEEP_PROXY: ${x-cfg-stage-1.build.apt.keep_proxy} # retain http proxy settings in apt after build? If false, proxy will be removed after build

        # given proxies
        USER_HTTP_PROXY: ${x-cfg-stage-1.build.proxy._proxy_http}
        USER_HTTPS_PROXY: ${x-cfg-stage-1.build.proxy._proxy_https}

        # installation dirs
        INSTALL_DIR_HOST_1: ${x-cfg-stage-1.paths._root_dir_host}
        INSTALL_DIR_CONTAINER_1: ${x-cfg-stage-1.paths._root_dir_container}

        # ssh port in container
        ROOT_PASSWORD: ${x-cfg-stage-1.build.root_password}

# create volumes if needed in stage 2
volumes: ${x-sections.mount[${x-cfg-stage-2.storage.type}].volumes}