<?xml version="1.0" encoding="UTF-8"?>
<memory>
  <item id="mem_1753763621909_ocbrx5ng5" time="2025/07/29 12:33">
    <content>
      # Tool Skill: NiceGUI Framework
    
      ## Core Concepts
      - Python-based web UI framework using FastAPI, Vue.js, and Quasar.
      - Declarative syntax, browser-based with hot-reloading.
    
      ## Key Patterns
      ```python
      from nicegui import ui
      
      # Core Usage
      ui.label(&#x27;Hello&#x27;)
      ui.button(&#x27;Click&#x27;, on_click=lambda: ui.notify(&#x27;Clicked!&#x27;))
      
      # Layout
      with ui.row():
          ui.label(&#x27;A&#x27;)
          ui.label(&#x27;B&#x27;)
          
      # Data Binding
      data = {&#x27;name&#x27;: &#x27;John&#x27;}
      ui.input().bind_value(data, &#x27;name&#x27;)
      
      # Dynamic Content
      @ui.refreshable
      def dynamic_content():
          ui.label(f&#x27;Time: {datetime.now()}&#x27;)
      ui.button(&#x27;Update&#x27;, on_click=dynamic_content.refresh)
      
      # Pages & Routing
      @ui.page(&#x27;/about&#x27;)
      def about_page():
          ui.label(&#x27;About&#x27;)
      
      ui.run()
      ```
      
      ## Best Practices
      - Use `@ui.refreshable` for dynamic UI.
      - Use context managers (`with ui.row():`) for layout.
      - Prefer data binding over manual value updates.
      - Use `app.storage.user` for session data.
    </content>
    <tags>#nicegui #python #web-ui</tags>
  </item>
  <item id="mem_1753763760284_vel8gqg9o" time="2025/07/29 12:36">
    <content>
      # Tool Skill: PlantUML for GUI Design
    
      ## Core Idea
      Use text to create UML diagrams for documenting GUI design, flows, and component states.
    
      ## Key Diagram Types
      - **State Diagrams**: Model component states (e.g., form validation, dialogs).
      - **Activity Diagrams**: Model user workflows and multi-step processes.
      - **Sequence Diagrams**: Model interactions between UI, services, and databases.
      - **Use Case Diagrams**: Model user goals and system features.
    
      ## Common GUI Design Patterns in PlantUML
    
      ### Modal Dialog State Machine
      ```plantuml
      @startuml
      [*] --> Closed
      Closed --> Opening : open_modal()
      Opening --> Opened
      Opened --> Closing : close_modal()
      Closing --> Closed
      @enduml
      ```
    
      ### Form Validation Pattern
      ```plantuml
      @startuml
      [*] --> Pristine
      Pristine --> Dirty : user_input
      Dirty --> Validating : on_blur
      Validating --> Valid : success
      Validating --> Invalid : error
      @enduml
      ```
    </content>
    <tags>#plantuml #uml #gui-design #documentation</tags>
  </item>
  <item id="mem_1753764952813_lxfu86u5n" time="2025/07/29 12:55">
    <content>
      # Engineering Skill: Standard Dev Tools
    
      A standard development environment often includes:
      - **Package Manager**: `poetry`, `pixi`, or `pip` for managing dependencies.
      - **Diagramming**: `graphviz` (dot) for architecture charts and `plantuml` for UML diagrams.
      - **Web Testing**: `playwright` for end-to-end browser automation.
      - **Media**: `imagemagick` for image processing and `ffmpeg` for video.
    </content>
    <tags>#devtools #engineering-practices</tags>
  </item>
  <item id="mem_1753765440275_cgl6w23x0" time="2025/07/29 13:04">
    <content>
      # Tool Skill: Testing Web UIs with Playwright
    
      ## Core Idea
      Use Playwright for end-to-end, cross-browser testing of web applications from Python.
    
      ## Basic Test Pattern
      ```python
      import pytest
      from playwright.async_api import async_playwright
      
      @pytest.mark.asyncio
      async def test_basic_interaction(web_app_url):
          async with async_playwright() as p:
              browser = await p.chromium.launch()
              page = await browser.new_page()
              
              await page.goto(web_app_url)
              assert await page.title() == "Expected Title"
              
              await page.click("button#submit")
              await page.wait_for_selector("text=Success")
              
              await page.screenshot(path="result.png")
              await browser.close()
      ```
      
      ## Key Techniques
      - **Setup**: `pip install playwright pytest-playwright` and `playwright install`.
      - **Wait Strategies**: Use `page.wait_for_selector()` or `page.wait_for_load_state('networkidle')` to handle dynamic content.
      - **Screenshots**: Use `page.screenshot()` for visual validation and debugging.
      - **Debugging**: Run with `headless=False` and `slow_mo=500` to observe execution.
    </content>
    <tags>#playwright #testing #e2e #python</tags>
  </item>
  <item id="mem_1753781054147_zo14bko3r" time="2025/07/29 17:24">
    <content>
      # Engineering Skill: Tracking Unsaved Changes in Web UIs
    
      ## Core Concept: "Dirty State"
      A "dirty state" occurs when form data is modified but not saved. This is crucial for warning users before they lose data.
    
      ## Implementation Pattern (NiceGUI Example)
      ```python
      from nicegui import ui
      
      # 1. Use reactive state for form data and dirty status
      form_data, set_form_data = ui.state({&#x27;field&#x27;: &#x27;&#x27;})
      is_dirty, set_is_dirty = ui.state(False)
      original_data = form_data.copy()
      
      def check_dirty():
          set_is_dirty(form_data != original_data)
          
      def save():
          # ... save logic ...
          original_data.clear()
          original_data.update(form_data)
          check_dirty()
          ui.notify(&#x27;Saved!&#x27;)
      
      # 2. Bind inputs and trigger check on change
      ui.input(&#x27;Field&#x27;).bind_value(form_data, &#x27;field&#x27;).on(&#x27;change&#x27;, check_dirty)
      
      # 3. Bind save button's enabled state to dirty status
      ui.button(&#x27;Save&#x27;, on_click=save).bind_enabled_from(is_dirty, &#x27;value&#x27;)
      ```
      
      ## Browser-Level Protection
      Use JavaScript's `beforeunload` event to warn users if they try to navigate away with unsaved changes.
      ```javascript
      window.addEventListener('beforeunload', (e) => {
        if (formIsDirty) {
          e.preventDefault();
          e.returnValue = 'You have unsaved changes!';
        }
      });
      ```
    </content>
    <tags>#ui-patterns #state-management #nicegui #ux</tags>
  </item>
  <item id="mem_1753783371936_khz73vql1" time="2025/07/29 18:02">
    <content>
      # Engineering Skill: Secure File Handling in Web Apps
    
      ## Core Principle: Server-Side Processing
      For security, all file operations (creation, modification, zipping) should be handled on the server. The server then provides a download link to the client.
    
      ## Key Implementation Pattern
      1. **Create a temporary workspace** on the server for file operations.
      2. **Perform all file modifications** within this secure server-side directory.
      3. **Validate all user-provided paths** to prevent directory traversal attacks.
      4. **Zip the results** into a single archive.
      5. **Serve the zip file** for download using a static endpoint or a dynamic response.
    
      ```python
      # Simplified Example
      import tempfile, zipfile
      from pathlib import Path
      from nicegui import app, ui
      
      def generate_and_download_files():
          with tempfile.TemporaryDirectory() as tmpdir:
              workspace = Path(tmpdir)
              # 1. Create files in secure temp workspace
              (workspace / 'file1.txt').write_text('Hello')
              
              # 2. Create a zip archive
              zip_path = workspace / "archive.zip"
              with zipfile.ZipFile(zip_path, 'w') as zf:
                  zf.write(workspace / 'file1.txt', 'file1.txt')
              
              # 3. Trigger download
              ui.download(zip_path)
      ```
      
      ## Security Best Practice
      Always validate user-provided paths to ensure they are within the intended base directory.
    </content>
    <tags>#security #file-handling #web-development #nicegui</tags>
  </item>
  <item id="mem_1753801600938_mupucn97k" time="2025/07/29 23:06">
    <content>
      # Engineering Skill: Executing Scripts in Dynamically Loaded HTML
    
      ### The Problem
      When using `fetch()` and `innerHTML` to load HTML content, any `<script>` tags within the loaded content **will not execute** due to browser security policies.
    
      ### The Solution
      Manually extract, create, and append the scripts to the DOM to trigger their execution.
    
      ```javascript
      async function loadContentWithScripts(targetElement, url) {
        // 1. Fetch content as text
        const response = await fetch(url);
        const html = await response.text();
        
        // 2. Parse and find scripts
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = html;
        const scripts = tempDiv.querySelectorAll('script');
        
        // 3. Add HTML to the page (without scripts)
        targetElement.innerHTML = tempDiv.innerHTML;
        
        // 4. Create and append new script elements to execute them
        scripts.forEach(script => {
          const newScript = document.createElement('script');
          if (script.src) {
            newScript.src = script.src;
          } else {
            newScript.textContent = script.textContent;
          }
          document.body.appendChild(newScript).remove(); // Append and immediately remove
        });
      }
      ```
      
      ### 🚨 Red Flags
      - Content loads, but buttons/forms are unresponsive.
      - Console error: "function is not defined".
      - Using `file://` protocol for testing (use a local HTTP server instead).
    </content>
    <tags>#javascript #web-development #dom #spa</tags>
  </item>
      endif
      :Continue flow;
      stop
      @enduml
      ```
    
      ### 3. Sequence Diagrams
      **Purpose**: Model interactions between UI components, backend services, and user actions over time.
    
      **Best for**: API calls and responses, component communication, event handling chains, asynchronous operations.
    
      **Basic Pattern**:
      ```plantuml
      @startuml
      actor User
      participant &quot;UI Component&quot; as UI
      participant &quot;Service&quot; as Service
      database &quot;Database&quot; as DB
    
      User -> UI : user_action
      UI -> Service : api_call()
      Service -> DB : query()
      DB --> Service : result
      Service --> UI : response
      UI --> User : updated_ui
      @enduml
      ```
    
      ### 4. Use Case Diagrams
      **Purpose**: Model user goals and system functionality from user perspective.
    
      **Best for**: Requirements gathering, feature overview, user role definition, system boundaries.
    
      **Basic Pattern**:
      ```plantuml
      @startuml
      left to right direction
      actor &quot;User Type&quot; as user
      rectangle &quot;System&quot; {
      usecase &quot;Feature 1&quot; as UC1
      usecase &quot;Feature 2&quot; as UC2
      }
      user --> UC1
      user --> UC2
      @enduml
      ```
    
      ## Advanced PlantUML Features
    
      ### Styling and Themes
      ```plantuml
      @startuml
      !theme cerulean-outline
    
      skinparam state {
      BackgroundColor LightBlue
      BorderColor DarkBlue
      FontColor Black
      }
    
      skinparam activity {
      BackgroundColor LightGreen
      BorderColor DarkGreen
      }
      @enduml
      ```
    
      ### Custom Stereotypes and Colors
      ```plantuml
      @startuml
      skinparam state {
      BackgroundColor&lt;&lt;UI&gt;&gt; LightCyan
      BackgroundColor&lt;&lt;Error&gt;&gt; LightPink
      BackgroundColor&lt;&lt;Loading&gt;&gt; LightYellow
      }
    
      state &quot;Login Screen&quot; &lt;&lt;UI&gt;&gt;
      state &quot;Error State&quot; &lt;&lt;Error&gt;&gt;
      @enduml
      ```
    
      ### Notes and Documentation
      ```plantuml
      @startuml
      state LoginForm {
      [*] --> Empty
      Empty --> Filled : user_input
    
      note right of Empty : Initial state when\nform loads
      note bottom of Filled : All validation\nrules active
      }
      @enduml
      ```
    
      ### Hierarchical State Organization
      ```plantuml
      @startuml
      state &quot;Application&quot; {
      state &quot;Authentication Flow&quot; {
      state Login
      state Register
      }
    
      state &quot;Main Application&quot; {
      state Dashboard
      state Settings
      }
      }
      @enduml
      ```
    
      ## Best Practices for GUI Documentation
    
      ### 1. Clear State Naming Conventions
      - Use descriptive names: `WaitingForUserInput` instead of `State1`
      - Include context: `LoginForm_ValidatingCredentials` instead of `Validating`
      - Be consistent across diagrams
    
      ### 2. Document State Transitions with Conditions
      ```plantuml
      @startuml
      state Form {
      Empty --> Filled : user_types_valid_email
      Filled --> Submitting : submit_button_clicked [form_valid]
      Submitting --> Success : api_success
      Submitting --> Error : api_error / show_error_message
      Error --> Filled : user_dismisses_error
      }
      @enduml
      ```
    
      ### 3. Version Control Integration
      ```plantuml
      @startuml
      !define VERSION v2.1.0
      title User Authentication Flow (VERSION)
    
      &#x27; Include modular components
      !include common-styles.puml
      @enduml
      ```
    
      ### 4. Configuration Variables for Flexibility
      ```plantuml
      @startuml
      !$SHOW_DETAILED_STATES = %true()
    
      !if $SHOW_DETAILED_STATES
      state DetailedValidation {
      state CheckFormat
      state CheckLength
      }
      !endif
      @enduml
      ```
    
      ## Common GUI Design Patterns
    
      ### Modal Dialog State Machine
      ```plantuml
      @startuml
      [*] --> Closed
      Closed --> Opening : open_modal()
      Opening --> Opened : animation_complete
      Opened --> Closing : close_modal() / save_data()
      Closing --> Closed : animation_complete
      Opened --> Opened : user_interaction / update_content()
      @enduml
      ```
    
      ### Form Validation Pattern
      ```plantuml
      @startuml
      [*] --> Pristine
      Pristine --> Dirty : user_input
      Dirty --> Validating : on_blur / validate_field()
      Validating --> Valid : validation_success
      Validating --> Invalid : validation_error / show_error()
      Valid --> Dirty : user_input
      Invalid --> Dirty : user_input
      @enduml
      ```
    
      ### Async Operation Pattern
      ```plantuml
      @startuml
      [*] --> Idle
      Idle --> Loading : start_operation()
      Loading --> Success : operation_complete
      Loading --> Error : operation_failed
      Success --> Idle : user_acknowledge
      Error --> Idle : user_retry
      Error --> Loading : auto_retry [retry_count &lt; 3]
      @enduml
      ```
    
      ## Development Workflow Integration
    
      ### Documentation-Driven Development Flow
      1. Create use case diagrams for requirements
      2. Design activity flows for user journeys
      3. Create detailed state diagrams for components
      4. Implement components based on diagrams
      5. Validate implementation against design
      6. Update diagrams or code as needed
    
      ### Living Documentation Strategy
      - Store PlantUML files in version control alongside code
      - Generate diagrams automatically in CI/CD pipeline
      - Embed generated diagrams in technical documentation
      - Link diagrams to design decisions and requirements
      - Use diagrams for code reviews and team collaboration
    
      ### Multi-Diagram Documentation Approach
      For comprehensive GUI documentation:
      - **Use Cases** → Requirements and user goals
      - **Activity Diagrams** → High-level user flows
      - **State Diagrams** → Detailed component behavior
      - **Sequence Diagrams** → Interaction details and timing
    
      ## PlantUML Integration Tools
      - **VS Code**: PlantUML extension for live preview
      - **IntelliJ IDEA**: Built-in PlantUML support
      - **Web Interface**: plantuml.com for quick prototyping
      - **CLI Tools**: Local PlantUML JAR for automation
    
      ## Export and Sharing Options
      - PNG/SVG for documentation embedding
      - PDF for printable specifications
      - ASCII for text-only environments
      - Direct integration with documentation platforms
    
      ## Review and Collaboration Patterns
      ```plantuml
      @startuml
      !procedure $review_state($name, $reviewer, $status)
      state $name {
      note right : Reviewed by: $reviewer\nStatus: $status
      }
      !endprocedure
    
      $review_state(&quot;LoginFlow&quot;, &quot;UI Team&quot;, &quot;Approved&quot;)
      $review_state(&quot;ValidationLogic&quot;, &quot;Backend Team&quot;, &quot;Under Review&quot;)
      @enduml
      ```
    
      ## Key Benefits for GUI Development
      - **Visual Requirements**: Clear communication of complex UI behavior
      - **Implementation Guide**: Step-by-step development roadmap
      - **Testing Reference**: Test cases derived from state transitions
      - **Maintenance Aid**: Understanding existing component behavior
      - **Team Collaboration**: Shared understanding of UI design
      - **Documentation Consistency**: Standardized diagram formats across projects
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753764952813_lxfu86u5n" time="2025/07/29 12:55">
    <content>
      # Engineering Skill Memory
    
      ## Available Development Tools for Python Projects
    
      The following tools are generally available in a well-equipped development environment for Python projects:
    
      ### Python Environment &amp; Testing
      - **Poetry/Pixi/Pip+Venv**: Python environment and package management tools.
      - These are the primary package managers for projects.
      - Used for installing dependencies and running development tasks.
    
      ### Documentation &amp; Diagramming Tools
      - **dot (graphviz)**: Graph visualization and diagramming.
      - Useful for creating architecture diagrams, workflow charts.
      - Can generate various output formats (PNG, SVG, PDF).
    
      - **plantuml**: UML diagram generation from text.
      - Excellent for documenting GUI design workflows and system architecture.
      - Can create state diagrams, sequence diagrams, activity diagrams.
      - Particularly useful for documenting UI workflows.
    
      ### Testing &amp; Validation Tools
      - **playwright**: Automated web testing framework.
      - **pytest-playwright**: Python bindings for Playwright.
      - Useful for testing web-based UI applications.
      - Can automate GUI interaction testing and is helpful for testing UI workflows.
    
      ### Media Processing Tools
      - **imagemagick**: Image processing and manipulation.
      - Can be used for creating screenshots, icons, or processing GUI assets.
      - Useful for documentation with visual examples.
    
      - **ffmpeg**: Video processing and conversion.
      - Could be used for creating demo videos of an application workflow.
      - Useful for documenting complex user interactions.
    
      ### Development Workflow Integration
      These tools complement a modern development workflow:
      1. Use **package managers** for running the application in development mode.
      2. Use **plantuml** to document workflows and screen architecture.
      3. Use **playwright** for automated testing of UI interactions.
      4. Use **graphviz** for visualizing configuration or data model relationships.
      5. Use **imagemagick** for processing any GUI assets or documentation screenshots.
    
      This tool ecosystem supports comprehensive development, testing, and documentation for modern software projects.
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753765440275_cgl6w23x0" time="2025/07/29 13:04">
    <content>
      # Tool Skill Memory
    
      ## Testing Web UI Applications with Playwright in Python
    
      Playwright is a powerful end-to-end testing framework for web applications that provides cross-browser automation capabilities. This skill applies to testing any Python-based web UI framework.
    
      ### Installation and Setup
      ```bash
      # Core installation
      pip install playwright pytest-playwright
    
      # Install browser drivers
      playwright install
    
      # Platform-specific drivers (if needed)
      # Linux: sudo apt-get install chromium-chromedriver
      # macOS: brew install chromedriver
      # Windows: choco install chromedriver
      ```
    
      ### Testing Approaches
    
      #### Method 1: Direct Playwright Testing
      ```python
      import asyncio
      import pytest
      from playwright.async_api import async_playwright
      import threading
      import time
    
      @pytest.fixture
      async def web_app():
      &quot;&quot;&quot;Start web app in separate thread&quot;&quot;&quot;
      def run_app():
      # Start your web framework here
      app.run(port=8080, show=False, reload=False)
    
      thread = threading.Thread(target=run_app, daemon=True)
      thread.start()
      time.sleep(2)  # Wait for server startup
      yield &quot;http://localhost:8080&quot;
    
      @pytest.mark.asyncio
      async def test_web_app_with_playwright(web_app):
      async with async_playwright() as p:
      browser = await p.chromium.launch(headless=True)
      page = await browser.new_page()
    
      await page.goto(web_app)
      await page.wait_for_selector(&#x27;text=Expected Content&#x27;)
    
      # Test interactions
      await page.click(&#x27;button:has-text(&quot;Click me&quot;)&#x27;)
      await page.fill(&#x27;input&#x27;, &#x27;Test input&#x27;)
    
      # Verify results
      assert await page.text_content(&#x27;h1&#x27;) == &#x27;Expected Title&#x27;
    
      await browser.close()
      ```
    
      ### Advanced Testing Scenarios
    
      #### Real-time Updates Testing
      ```python
      @pytest.mark.asyncio
      async def test_realtime_updates(web_app):
      async with async_playwright() as p:
      browser = await p.chromium.launch()
      page = await browser.new_page()
    
      await page.goto(web_app)
    
      # Wait for WebSocket connection
      await page.wait_for_function(
      &quot;window.socket &amp;&amp; window.socket.connected&quot;
      )
    
      # Test dynamic updates
      await page.click(&#x27;button:has-text(&quot;Update Counter&quot;)&#x27;)
      await page.wait_for_function(
      &quot;document.querySelector(&#x27;#counter&#x27;).textContent !== &#x27;0&#x27;&quot;
      )
    
      await browser.close()
      ```
    
      #### Cross-Browser Testing
      ```python
      @pytest.mark.parametrize(&quot;browser_name&quot;, [&quot;chromium&quot;, &quot;firefox&quot;, &quot;webkit&quot;])
      @pytest.mark.asyncio
      async def test_cross_browser(web_app, browser_name):
      async with async_playwright() as p:
      browser = await getattr(p, browser_name).launch()
      page = await browser.new_page()
    
      await page.goto(web_app)
      # Perform cross-browser tests
    
      await browser.close()
      ```
    
      ### Screenshot Capabilities
    
      #### Full Page Screenshots
      ```python
      @pytest.mark.asyncio
      async def test_full_page_screenshot(web_app):
      async with async_playwright() as p:
      browser = await p.chromium.launch(headless=True)
      context = await browser.new_context(
      viewport={&quot;width&quot;: 1280, &quot;height&quot;: 720}
      )
      page = await context.new_page()
    
      await page.goto(web_app)
      await page.wait_for_load_state(&quot;networkidle&quot;)
    
      # Full page screenshot
      await page.screenshot(
      path=&quot;full_page_screenshot.png&quot;,
      full_page=True
      )
    
      await browser.close()
      ```
    
      #### Element-Specific Screenshots
      ```python
      # Screenshot specific components
      await page.locator(&#x27;.content-section&#x27;).screenshot(
      path=&quot;content_section.png&quot;
      )
    
      # Screenshot with custom options
      await page.screenshot(
      path=&quot;custom_screenshot.png&quot;,
      full_page=True,
      quality=95,  # For JPEG
      type=&quot;png&quot;,
      clip={       # Specific area
      &quot;x&quot;: 0, &quot;y&quot;: 0,
      &quot;width&quot;: 800, &quot;height&quot;: 600
      }
      )
      ```
    
      #### Screenshots as Base64 Buffer
      ```python
      # In-memory screenshot processing
      screenshot_bytes = await page.screenshot()
      import base64
      screenshot_b64 = base64.b64encode(screenshot_bytes).decode()
      ```
    
      #### Visual Regression Testing
      ```python
      import filecmp
      from pathlib import Path
    
      @pytest.mark.asyncio
      async def test_visual_regression(web_app):
      # Take current screenshot
      await page.screenshot(path=&quot;current_ui.png&quot;, full_page=True)
    
      # Compare with baseline
      if Path(&quot;baseline_ui.png&quot;).exists():
      assert filecmp.cmp(&quot;current_ui.png&quot;, &quot;baseline_ui.png&quot;), \
      &quot;UI has changed compared to baseline&quot;
      else:
      # Establish baseline on first run
      import shutil
      shutil.copy(&quot;current_ui.png&quot;, &quot;baseline_ui.png&quot;)
      ```
    
      ### Configuration and Best Practices
    
      #### pytest Configuration (pytest.ini)
      ```ini
      [tool:pytest]
      asyncio_mode = auto
      testpaths = tests
      addopts =
      --browser chromium
      --headed
      --slowmo 100
      ```
    
      #### Environment Configuration (conftest.py)
      ```python
      @pytest.fixture(scope=&quot;session&quot;)
      async def browser():
      async with async_playwright() as p:
      browser = await p.chromium.launch(
      headless=False,  # Set True for CI/CD
      slow_mo=50      # Debugging aid
      )
      yield browser
      await browser.close()
    
      @pytest.fixture
      async def page(browser):
      page = await browser.new_page()
      yield page
      await page.close()
      ```
    
      #### Screenshot on Test Failure
      ```python
      @pytest.fixture(autouse=True)
      async def screenshot_on_failure(request):
      yield
    
      if request.node.rep_call.failed:
      if hasattr(request.node, &#x27;_page&#x27;):
      page = request.node._page
      screenshot_path = f&quot;failure_{request.node.name}_{int(time.time())}.png&quot;
      await page.screenshot(path=screenshot_path, full_page=True)
      ```
    
      ### Common Challenges and Solutions
    
      #### Dynamic Content Loading
      ```python
      # Wait for specific element
      await page.wait_for_selector(&#x27;.dynamic-content&#x27;)
    
      # Wait for network idle
      await page.wait_for_load_state(&#x27;networkidle&#x27;)
    
      # Wait for custom condition
      await page.wait_for_function(&quot;customCondition()&quot;)
      ```
    
      #### WebSocket Connection Handling
      ```python
      # Ensure WebSocket is connected
      await page.wait_for_function(
      &quot;window.socket &amp;&amp; window.socket.connected&quot;
      )
      ```
    
      ### Mobile Device Testing
      ```python
      # Emulate mobile device
      mobile_context = await browser.new_context(
      viewport={&quot;width&quot;: 375, &quot;height&quot;: 667},  # iPhone SE
      user_agent=&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 14_7 like Mac OS X)&quot;,
      is_mobile=True,
      has_touch=True
      )
      ```
    
      ### Performance Testing
      ```python
      @pytest.mark.asyncio
      async def test_performance(web_app):
      # Start performance monitoring
      await page.evaluate(&quot;performance.mark(&#x27;start&#x27;)&quot;)
    
      await page.goto(web_app)
      await page.wait_for_selector(&#x27;text=Content&#x27;)
    
      # Measure performance
      await page.evaluate(&quot;performance.mark(&#x27;end&#x27;)&quot;)
      duration = await page.evaluate(&quot;&quot;&quot;
      performance.measure(&#x27;test&#x27;, &#x27;start&#x27;, &#x27;end&#x27;);
      performance.getEntriesByName(&#x27;test&#x27;)[0].duration;
      &quot;&quot;&quot;)
    
      assert duration &lt; 2000  # Less than 2 seconds
      ```
    
      ### Best Practices
    
      1. **Consistent Viewport**: Always set fixed viewport for consistent screenshots
      2. **Wait Strategies**: Use appropriate wait strategies for dynamic content
      3. **Resource Management**: Properly close browsers and contexts
      4. **Error Handling**: Implement screenshot capture on test failures
      5. **CI/CD Integration**: Configure headless mode for automated pipelines
      6. **Cross-browser Coverage**: Test across multiple browsers
      7. **Performance Monitoring**: Include performance assertions
      8. **Visual Testing**: Implement screenshot comparison for UI regression
      9. **Mobile Testing**: Include responsive design testing
    
      ### Debugging Tips
      - Use `headless=False` for visual debugging
      - Add `page.pause()` to open Playwright inspector
      - Implement automatic screenshot capture on failures
      - Use `slow_mo` parameter to slow down actions for observation
      - Wait for `networkidle` state before taking screenshots
    
      This comprehensive testing approach with Playwright enables robust end-to-end testing of any web-based UI application across multiple browsers and scenarios.
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753781054147_zo14bko3r" time="2025/07/29 17:24">
    <content>
      # Tool Skill Memory
    
      ## Tracking Unsaved Changes in NiceGUI Applications
    
      This covers comprehensive techniques for implementing &quot;dirty state&quot; tracking in NiceGUI applications to prevent data loss and provide user feedback about unsaved modifications.
    
      ### Core Concepts
    
      **Dirty State Definition**: The condition where form data has been modified by the user but not yet saved to persistent storage. Essential for:
      - Warning users before leaving page with unsaved changes
      - Enabling/disabling save buttons based on modification status
      - Providing visual feedback about unsaved changes
      - Implementing auto-save functionality
    
      **Key Components**: State tracking, user warning, visual feedback, save management
    
      ### NiceGUI Reactive Variables Approach
    
      ```python
      from nicegui import ui
    
      @ui.page(&#x27;/&#x27;)
      def main_page():
      # Create reactive state variables
      form_data, set_form_data = ui.state({
      &#x27;field1&#x27;: &#x27;&#x27;,
      &#x27;field2&#x27;: &#x27;&#x27;,
      &#x27;field3&#x27;: &#x27;&#x27;
      })
    
      # Track if form is dirty
      is_dirty, set_is_dirty = ui.state(False)
      original_data, set_original_data = ui.state({})
    
      def check_dirty():
      dirty = form_data != original_data
      set_is_dirty(dirty)
    
      def save_form():
      # Save logic here
      set_original_data(form_data.copy())
      set_is_dirty(False)
      ui.notify(&#x27;Changes saved!&#x27;)
    
      # Form inputs with change tracking
      ui.input(&#x27;Field 1&#x27;).bind_value(form_data, &#x27;field1&#x27;).on(&#x27;change&#x27;, check_dirty)
      ui.input(&#x27;Field 2&#x27;).bind_value(form_data, &#x27;field2&#x27;).on(&#x27;change&#x27;, check_dirty)
      ui.textarea(&#x27;Field 3&#x27;).bind_value(form_data, &#x27;field3&#x27;).on(&#x27;change&#x27;, check_dirty)
    
      # Save button enabled only when dirty
      ui.button(&#x27;Save&#x27;, on_click=save_form).bind_enabled_from(is_dirty, &#x27;value&#x27;)
    
      # Status indicator
      ui.label().bind_text_from(is_dirty, &#x27;value&#x27;,
      lambda dirty: &#x27;● Unsaved changes&#x27; if dirty else &#x27;✓ All changes saved&#x27;)
      ```
    
      ### Class-Based State Management
    
      ```python
      class FormState:
      def __init__(self):
      self.field1 = &#x27;&#x27;
      self.field2 = &#x27;&#x27;
      self.is_dirty = False
      self.original_state = {}
    
      def mark_dirty(self):
      self.is_dirty = True
    
      def save(self):
      # Save logic
      self.original_state = self.get_current_state()
      self.is_dirty = False
    
      def get_current_state(self):
      return {
      &#x27;field1&#x27;: self.field1,
      &#x27;field2&#x27;: self.field2
      }
    
      def check_changes(self):
      current = self.get_current_state()
      self.is_dirty = current != self.original_state
    
      @ui.page(&#x27;/&#x27;)
      def form_page():
      state = FormState()
    
      # Bind form fields to state object
      ui.input(&#x27;Field 1&#x27;).bind_value(state, &#x27;field1&#x27;).on(&#x27;change&#x27;, state.check_changes)
      ui.input(&#x27;Field 2&#x27;).bind_value(state, &#x27;field2&#x27;).on(&#x27;change&#x27;, state.check_changes)
    
      # UI elements that reflect dirty state
      ui.button(&#x27;Save&#x27;, on_click=state.save).bind_enabled_from(state, &#x27;is_dirty&#x27;)
      ui.label().bind_text_from(state, &#x27;is_dirty&#x27;,
      lambda dirty: &#x27;Unsaved changes&#x27; if dirty else &#x27;Saved&#x27;)
      ```
    
      ### Refreshable UI Pattern
    
      ```python
      form_data = {&#x27;field1&#x27;: &#x27;&#x27;, &#x27;field2&#x27;: &#x27;&#x27;}
      original_data = {}
      is_dirty = False
    
      def check_dirty():
      global is_dirty
      is_dirty = form_data != original_data
      status_display.refresh()
    
      @ui.refreshable
      def status_display():
      if is_dirty:
      ui.label(&#x27;● Unsaved changes&#x27;).classes(&#x27;text-orange-600&#x27;)
      else:
      ui.label(&#x27;✓ All saved&#x27;).classes(&#x27;text-green-600&#x27;)
    
      @ui.refreshable
      def save_button():
      ui.button(&#x27;Save&#x27;, on_click=save_changes).props(&#x27;disable&#x27; if not is_dirty else &#x27;&#x27;)
    
      def save_changes():
      global original_data, is_dirty
      # Save logic here
      original_data = form_data.copy()
      is_dirty = False
      save_button.refresh()
      status_display.refresh()
      ui.notify(&#x27;Changes saved!&#x27;)
      ```
    
      ### Browser-Level Protection
    
      ```python
      @ui.page(&#x27;/&#x27;)
      def protected_form():
      is_dirty, set_is_dirty = ui.state(False)
    
      # JavaScript to warn on page unload
      ui.add_head_html(&quot;&quot;&quot;
      &lt;script&gt;
      let formDirty = false;
    
      function setFormDirty(dirty) {
      formDirty = dirty;
      }
    
      window.addEventListener(&#x27;beforeunload&#x27;, function(e) {
      if (formDirty) {
      e.preventDefault();
      e.returnValue = &#x27;You have unsaved changes. Are you sure you want to leave?&#x27;;
      return e.returnValue;
      }
      });
    
      document.addEventListener(&#x27;submit&#x27;, function() {
      formDirty = false;
      });
      &lt;/script&gt;
      &quot;&quot;&quot;)
    
      def mark_dirty():
      set_is_dirty(True)
      ui.run_javascript(&#x27;setFormDirty(true)&#x27;)
    
      def save_form():
      set_is_dirty(False)
      ui.run_javascript(&#x27;setFormDirty(false)&#x27;)
      ui.notify(&#x27;Saved!&#x27;)
    
      # Form inputs
      ui.input(&#x27;Field 1&#x27;).on(&#x27;change&#x27;, mark_dirty)
      ui.input(&#x27;Field 2&#x27;).on(&#x27;change&#x27;, mark_dirty)
      ui.button(&#x27;Save&#x27;, on_click=save_form)
      ```
    
      ### Advanced Browser Protection with FormTracker
    
      ```python
      ui.add_head_html(&quot;&quot;&quot;
      &lt;script&gt;
      class FormTracker {
      constructor() {
      this.originalData = {};
      this.isDirty = false;
      this.isSubmitting = false;
      this.init();
      }
    
      init() {
      this.captureOriginalState();
    
      document.addEventListener(&#x27;input&#x27;, (e) =&gt; {
      this.checkDirty();
      });
    
      document.addEventListener(&#x27;submit&#x27;, (e) =&gt; {
      this.isSubmitting = true;
      });
    
      window.addEventListener(&#x27;beforeunload&#x27;, (e) =&gt; {
      if (this.isDirty &amp;&amp; !this.isSubmitting) {
      e.preventDefault();
      e.returnValue = &#x27;Changes you made may not be saved.&#x27;;
      return e.returnValue;
      }
      });
      }
    
      captureOriginalState() {
      const inputs = document.querySelectorAll(&#x27;input, textarea, select&#x27;);
      inputs.forEach(input =&gt; {
      this.originalData[input.name || input.id] = input.value;
      });
      }
    
      checkDirty() {
      const inputs = document.querySelectorAll(&#x27;input, textarea, select&#x27;);
      this.isDirty = false;
    
      inputs.forEach(input =&gt; {
      const key = input.name || input.id;
      if (this.originalData[key] !== input.value) {
      this.isDirty = true;
      }
      });
    
      window.postMessage({
      type: &#x27;form-dirty-state&#x27;,
      isDirty: this.isDirty
      }, &#x27;*&#x27;);
      }
    
      markClean() {
      this.captureOriginalState();
      this.isDirty = false;
      this.isSubmitting = false;
      }
      }
    
      const formTracker = new FormTracker();
      window.formTracker = formTracker;
      &lt;/script&gt;
      &quot;&quot;&quot;)
      ```
    
      ### Visual Status Indicators
    
      ```python
      @ui.page(&#x27;/&#x27;)
      def form_with_indicators():
      is_dirty, set_is_dirty = ui.state(False)
    
      def update_status():
      set_is_dirty(True)
    
      def save_changes():
      set_is_dirty(False)
      ui.notify(&#x27;Changes saved!&#x27;, type=&#x27;positive&#x27;)
    
      # Header with status
      with ui.header():
      ui.label(&#x27;Form Title&#x27;)
      ui.space()
      with ui.row():
      ui.icon(&#x27;circle&#x27;, size=&#x27;sm&#x27;).bind_color_from(
      is_dirty, &#x27;value&#x27;,
      lambda dirty: &#x27;orange&#x27; if dirty else &#x27;green&#x27;
      )
      ui.label().bind_text_from(
      is_dirty, &#x27;value&#x27;,
      lambda dirty: &#x27;Unsaved changes&#x27; if dirty else &#x27;All saved&#x27;
      )
    
      # Form inputs
      ui.input(&#x27;Field 1&#x27;).on(&#x27;change&#x27;, update_status)
      ui.textarea(&#x27;Field 2&#x27;).on(&#x27;change&#x27;, update_status)
    
      # Save button with visual state
      ui.button(&#x27;Save Changes&#x27;, on_click=save_changes).bind_enabled_from(is_dirty, &#x27;value&#x27;)
      ```
    
      ### Tab-Based Forms with Individual Status
    
      ```python
      @ui.page(&#x27;/&#x27;)
      def tabbed_form():
      # Track dirty state for each tab
      tab_states = {
      &#x27;tab1&#x27;: ui.state(False),
      &#x27;tab2&#x27;: ui.state(False),
      &#x27;tab3&#x27;: ui.state(False)
      }
    
      def mark_tab_dirty(tab_name):
      tab_states[tab_name][1](True)
    
      def get_tab_label(tab_name, base_label):
      is_dirty = tab_states[tab_name][0]
      return f&quot;{base_label} {&#x27;●&#x27; if is_dirty else &#x27;&#x27;}&quot;
    
      with ui.tabs() as tabs:
      tab1 = ui.tab(&#x27;tab1&#x27;)
      tab2 = ui.tab(&#x27;tab2&#x27;)
      tab3 = ui.tab(&#x27;tab3&#x27;)
    
      with ui.tab_panels(tabs, value=&#x27;tab1&#x27;):
      with ui.tab_panel(&#x27;tab1&#x27;):
      ui.input(&#x27;Field A&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab1&#x27;))
      ui.input(&#x27;Field B&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab1&#x27;))
    
      with ui.tab_panel(&#x27;tab2&#x27;):
      ui.input(&#x27;Field C&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab2&#x27;))
      ui.number(&#x27;Field D&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab2&#x27;))
    
      with ui.tab_panel(&#x27;tab3&#x27;):
      ui.textarea(&#x27;Field E&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab3&#x27;))
    
      # Update tab labels to show dirty state
      @ui.refreshable
      def update_tab_labels():
      tab1.set_text(get_tab_label(&#x27;tab1&#x27;, &#x27;Tab 1&#x27;))
      tab2.set_text(get_tab_label(&#x27;tab2&#x27;, &#x27;Tab 2&#x27;))
      tab3.set_text(get_tab_label(&#x27;tab3&#x27;, &#x27;Tab 3&#x27;))
      ```
    
      ### Performance Optimization with Debouncing
    
      ```python
      import asyncio
    
      @ui.page(&#x27;/&#x27;)
      def optimized_form():
      debounce_timer = None
    
      async def debounced_check():
      nonlocal debounce_timer
      if debounce_timer:
      debounce_timer.cancel()
    
      debounce_timer = asyncio.create_task(asyncio.sleep(0.5))
      try:
      await debounce_timer
      # Perform expensive state check here
      check_form_state()
      except asyncio.CancelledError:
      pass
    
      def check_form_state():
      # State checking logic
      pass
    
      ui.input(&#x27;Search&#x27;).on(&#x27;change&#x27;, lambda: asyncio.create_task(debounced_check()))
      ```
    
      ### Error Handling Pattern
    
      ```python
      @ui.page(&#x27;/&#x27;)
      def robust_form():
      def save_with_validation():
      try:
      if not validate_form():
      ui.notify(&#x27;Please fix validation errors&#x27;, type=&#x27;negative&#x27;)
      return
    
      save_data()
      ui.notify(&#x27;Saved successfully!&#x27;, type=&#x27;positive&#x27;)
    
      except Exception as e:
      ui.notify(f&#x27;Save failed: {str(e)}&#x27;, type=&#x27;negative&#x27;)
    
      def validate_form():
      # Validation logic
      return True
    
      def save_data():
      # Save logic
      pass
      ```
    
      ### Memory Management
    
      ```python
      from nicegui import ui, app
    
      @ui.page(&#x27;/&#x27;)
      def memory_conscious_form():
      # Use app.storage for persistent state
      if &#x27;form_data&#x27; not in app.storage.user:
      app.storage.user[&#x27;form_data&#x27;] = {}
    
      # Clean up on page exit
      def cleanup():
      # Clean up resources
      pass
    
      # Register cleanup
      ui.context.client.on_disconnect(cleanup)
      ```
    
      ### Best Practices
    
      1. **Performance**: Use debounce for input events, leverage reactive variables, minimize DOM updates
      2. **Error Handling**: Validate before save, provide clear error messages, handle exceptions gracefully
      3. **Memory Management**: Clean up resources, use app.storage for persistence
      4. **User Experience**: Provide visual feedback, warn before data loss, enable/disable actions appropriately
      5. **Browser Compatibility**: Test beforeunload behavior across browsers
    
      ### Common Pitfalls
    
      - Not clearing dirty state on successful save
      - Excessive event handlers without debouncing
      - Memory leaks from unhandled event listeners
      - Race conditions in async operations
      - Not handling form submission states properly
    
      ### Implementation Checklist
    
      - [ ] Choose appropriate state tracking method
      - [ ] Implement change detection for all form fields
      - [ ] Add browser-level protection against data loss
      - [ ] Provide visual feedback for unsaved changes
      - [ ] Handle form submission and state reset
      - [ ] Add validation and error handling
      - [ ] Test edge cases (refresh, navigation, etc.)
      - [ ] Optimize performance for large forms
    
      This comprehensive approach ensures robust unsaved change tracking in any NiceGUI application, preventing data loss and providing excellent user experience.
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753783371936_khz73vql1" time="2025/07/29 18:02">
    <content>
      # Tool Skill Memory
    
      ## File Handling Best Practices in NiceGUI Applications
    
      ### Architectural Approach: Server-Side vs Client-Side
    
      **Recommended Approach: Server-Side Processing**
      - Files are created and managed on server filesystem
      - Python handles all file operations and zipping
      - Files are served to browser for download
      - Maintains security, follows NiceGUI&#x27;s backend-first philosophy
    
      **Why Server-Side is Preferred:**
      - Security isolation and input validation
      - Alignment with NiceGUI/FastAPI architecture
      - Better error handling and resource management
      - Cross-platform compatibility and scalability
    
      ### Core Implementation Patterns
    
      #### Basic Server-Side File Operations
      ```python
      import tempfile
      import zipfile
      from pathlib import Path
      from nicegui import app, ui
    
      def create_workspace():
      &quot;&quot;&quot;Create temporary directory for user modifications&quot;&quot;&quot;
      temp_dir = Path(tempfile.mkdtemp())
      app.storage.user[&#x27;workspace_dir&#x27;] = str(temp_dir)
    
      # Initialize structure
      (temp_dir / &#x27;config&#x27;).mkdir()
      (temp_dir / &#x27;data&#x27;).mkdir()
    
      ui.notify(&#x27;Workspace created&#x27;, type=&#x27;positive&#x27;)
      return temp_dir
    
      def zip_and_download():
      &quot;&quot;&quot;Create zip file and trigger download&quot;&quot;&quot;
      workspace_dir = Path(app.storage.user.get(&#x27;workspace_dir&#x27;, &#x27;&#x27;))
    
      if not workspace_dir.exists():
      ui.notify(&#x27;No workspace found&#x27;, type=&#x27;negative&#x27;)
      return
    
      # Create zip file
      zip_path = workspace_dir.parent / f&quot;{workspace_dir.name}.zip&quot;
    
      with zipfile.ZipFile(zip_path, &#x27;w&#x27;, zipfile.ZIP_DEFLATED) as zipf:
      for file_path in workspace_dir.rglob(&#x27;*&#x27;):
      if file_path.is_file():
      arcname = file_path.relative_to(workspace_dir)
      zipf.write(file_path, arcname)
    
      # Make available for download
      app.add_static_file(&#x27;/download.zip&#x27;, str(zip_path))
      ui.download(&#x27;/download.zip&#x27;, f&#x27;workspace-{workspace_dir.name}.zip&#x27;)
      ```
    
      #### Advanced Workspace Management Pattern
      ```python
      import shutil
      from datetime import datetime, timedelta
    
      class WorkspaceManager:
      def __init__(self):
      self.base_dir = Path(tempfile.gettempdir()) / &#x27;app_workspaces&#x27;
      self.base_dir.mkdir(exist_ok=True)
    
      def create_workspace(self, user_id: str) -&gt; Path:
      timestamp = datetime.now().strftime(&#x27;%Y%m%d_%H%M%S&#x27;)
      workspace_dir = self.base_dir / f&quot;user_{user_id}_{timestamp}&quot;
      workspace_dir.mkdir(parents=True)
    
      # Initialize structure
      self._init_workspace_structure(workspace_dir)
      return workspace_dir
    
      def cleanup_old_workspaces(self, max_age_hours: int = 24):
      cutoff_time = datetime.now() - timedelta(hours=max_age_hours)
    
      for workspace in self.base_dir.iterdir():
      if workspace.is_dir() and workspace.stat().st_mtime &lt; cutoff_time.timestamp():
      shutil.rmtree(workspace)
    
      # Usage pattern
      workspace_manager = WorkspaceManager()
      app.on_startup(lambda: workspace_manager.cleanup_old_workspaces())
      ```
    
      ### NiceGUI Storage Options
    
      **Choose appropriate storage based on data lifetime:**
      ```python
      # User storage - persistent across sessions
      app.storage.user[&#x27;workspace_dir&#x27;] = str(workspace_path)
    
      # Tab storage - session-specific, more secure
      app.storage.tab[&#x27;temp_workspace&#x27;] = str(temp_path)
    
      # Client storage - per-connection
      app.storage.client[&#x27;active_files&#x27;] = file_list
    
      # Browser storage - stored in browser localStorage
      app.storage.browser[&#x27;user_settings&#x27;] = settings_dict
      ```
    
      ### Error Handling Pattern
      ```python
      async def safe_file_operation():
      try:
      workspace_dir = Path(app.storage.user.get(&#x27;workspace_dir&#x27;))
    
      if not workspace_dir.exists():
      raise FileNotFoundError(&quot;Workspace not found&quot;)
    
      # Perform file operations
      result = await some_file_operation(workspace_dir)
      ui.notify(&#x27;Operation completed successfully&#x27;, type=&#x27;positive&#x27;)
      return result
    
      except FileNotFoundError as e:
      ui.notify(f&#x27;File error: {e}&#x27;, type=&#x27;negative&#x27;)
      except PermissionError as e:
      ui.notify(&#x27;Permission denied&#x27;, type=&#x27;negative&#x27;)
      except Exception as e:
      ui.notify(f&#x27;Unexpected error: {e}&#x27;, type=&#x27;negative&#x27;)
      ```
    
      ### Security Best Practices
    
      #### Path Validation
      ```python
      def validate_file_path(user_path: str, base_dir: Path) -&gt; bool:
      &quot;&quot;&quot;Prevent directory traversal attacks&quot;&quot;&quot;
      try:
      resolved_path = (base_dir / user_path).resolve()
      return base_dir.resolve() in resolved_path.parents
      except:
      return False
      ```
    
      #### File Size and Type Restrictions
      ```python
      MAX_WORKSPACE_SIZE = 100 * 1024 * 1024  # 100MB
      ALLOWED_EXTENSIONS = {&#x27;.txt&#x27;, &#x27;.md&#x27;, &#x27;.json&#x27;, &#x27;.yaml&#x27;, &#x27;.yml&#x27;, &#x27;.py&#x27;}
    
      def check_workspace_size(workspace_dir: Path) -&gt; bool:
      total_size = sum(f.stat().st_size for f in workspace_dir.rglob(&#x27;*&#x27;) if f.is_file())
      return total_size &lt;= MAX_WORKSPACE_SIZE
    
      def is_allowed_file(file_path: Path) -&gt; bool:
      return file_path.suffix.lower() in ALLOWED_EXTENSIONS
      ```
    
      ### Download Implementation Patterns
    
      #### Static File Serving
      ```python
      # Add file to static files and trigger download
      app.add_static_file(&#x27;/download/file.zip&#x27;, str(zip_path))
      ui.download(&#x27;/download/file.zip&#x27;, &#x27;filename.zip&#x27;)
      ```
    
      #### Dynamic File Generation
      ```python
      def generate_and_download():
      # Generate content dynamically
      content = generate_file_content()
    
      # Write to temporary file
      temp_file = Path(tempfile.mktemp(suffix=&#x27;.txt&#x27;))
      temp_file.write_text(content)
    
      # Serve for download
      app.add_static_file(&#x27;/generated.txt&#x27;, str(temp_file))
      ui.download(&#x27;/generated.txt&#x27;, &#x27;generated_file.txt&#x27;)
      ```
    
      ### Deployment Considerations
    
      #### Local Development
      - Use temporary directories for file operations
      - Implement cleanup routines for development
      - Simple single-user file management
    
      #### Production Deployment
      - Consider persistent storage solutions
      - Implement proper user authentication
      - Add rate limiting and resource quotas
      - Use container-friendly storage patterns
    
      #### Docker Deployment
      ```python
      # Use environment variables for configuration
      WORKSPACE_BASE = Path(os.environ.get(&#x27;WORKSPACE_DIR&#x27;, &#x27;/app/workspaces&#x27;))
      WORKSPACE_BASE.mkdir(exist_ok=True)
      ```
    
      ### Key Principles
    
      1. **Always use server-side file processing** for security and architecture alignment
      2. **Choose appropriate NiceGUI storage** based on data lifetime requirements
      3. **Implement proper error handling** with user-friendly feedback
      4. **Validate file paths and types** to prevent security vulnerabilities
      5. **Clean up temporary files** to prevent resource exhaustion
      6. **Use Path objects** for cross-platform file system operations
      7. **Provide clear user feedback** for all file operations
    
      ### Common Anti-Patterns to Avoid
    
      - Storing sensitive data in client-side storage
      - Not validating file paths (directory traversal vulnerability)
      - Missing cleanup routines for temporary files
      - Using inappropriate storage types for data lifetime
      - Poor error handling without user feedback
      - Client-side file processing for complex operations
    
      This approach ensures secure, reliable, and maintainable file handling in any NiceGUI application while following framework best practices.
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753963571071_j7dm1cnu0" time="2025/07/31 20:06">
    <content>
      # Comprehensive NiceGUI-Playwright Testing Methodology
    
      ## Core Testing Approaches
      - **NiceGUI Built-in Testing**: Use `Screen` class for simple tests (`screen.open(&#x27;/&#x27;); screen.should_contain(&#x27;text&#x27;)`)
      - **Playwright Direct Integration**: Advanced end-to-end testing with browser automation across Chromium, Firefox, WebKit
    
      ## Critical NiceGUI-Specific Patterns
      - **WebSocket Connection Verification**: `await page.wait_for_function(&quot;window.socket &amp;&amp; window.socket.connected&quot;)`
      - **Vue.js App Readiness**: `await page.wait_for_function(&quot;window.Vue &amp;&amp; window.app&quot;)`
      - **Real-time Updates Testing**: Wait for dynamic content using specific selectors or network idle states
      - **Notification Testing**: Target `.q-notification` class for NiceGUI notifications
    
      ## Advanced Screenshot Capabilities
      - **Full Page Screenshots**: `await page.screenshot(path=&quot;screenshot.png&quot;, full_page=True)` with consistent viewport settings
      - **Element-Specific Screenshots**: `await page.locator(&#x27;.nicegui-content&#x27;).screenshot(path=&quot;element.png&quot;)`
      - **Visual Regression Testing**: Compare screenshots over time using file comparison or specialized image diff libraries
      - **Progressive Screenshots**: Capture before/after states for dynamic interactions
      - **Mobile Device Testing**: Use device context for responsive design validation
    
      ## Production Testing Infrastructure
      - **Cross-Browser Testing**: Parametrized tests across browser engines
      - **CI/CD Integration**: GitHub Actions with `playwright install --with-deps`
      - **Performance Testing**: Use `performance.mark()` and `performance.measure()` for timing validation
      - **Automatic Failure Screenshots**: Capture screenshots when tests fail for debugging
    
      ## Key Technical Implementation Details
      - **Test App Fixture**: Start NiceGUI in separate thread with proper startup timing
      - **Consistent Configuration**: Fixed viewport sizes, device scale factors, wait strategies
      - **Resource Management**: Proper browser/page cleanup in async contexts
      - **Error Handling**: Comprehensive exception handling with user-friendly test feedback
    
      ## Best Practices Framework
      - Always wait for `networkidle` state before taking screenshots
      - Use descriptive test names and organized screenshot storage
      - Implement proper cleanup routines for temporary resources
      - Configure headless vs headed modes appropriately for debugging vs CI
      - Use appropriate wait strategies for different types of dynamic content
    
      This methodology enables robust, maintainable testing of any NiceGUI application with comprehensive coverage across browsers, devices, and interaction patterns.
    </content>
    <tags>#其他</tags>
  </item>
</memory>
