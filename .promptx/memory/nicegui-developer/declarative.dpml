<?xml version="1.0" encoding="UTF-8"?>
<memory>
  <item id="mem_1753763621909_ocbrx5ng5" time="2025/07/29 12:33">
    <content>
      # Tool Skill Memory
    
      ## NiceGUI Framework Overview
      NiceGUI is a Python-based web UI framework built on FastAPI, Vue.js, and Quasar. It runs in browsers or as native desktop apps. Key characteristics:
      - Browser-based GUI with automatic hot reloading
      - Python-first approach with declarative syntax
      - Built on FastAPI/Starlette with WebSocket communication
      - Supports both web server mode and native desktop mode
    
      ## Core Usage Pattern
      ```python
      from nicegui import ui
    
      # Basic structure: declare UI elements, then run
      ui.label(&#x27;Hello World&#x27;)
      ui.button(&#x27;Click me&#x27;, on_click=lambda: ui.notify(&#x27;Clicked!&#x27;))
      ui.run()  # Starts the server
      ```
    
      ## Essential UI Components
      **Basic Elements**: label, button, input, textarea, checkbox, switch, radio, select, slider, range, knob, rating, image, video, audio, icon
      **Layout Elements**: row, column, card, grid, header, footer, drawer, separator, space, splitter
      **Advanced Elements**: table, aggrid, plotly, pyplot, echart, scene (3D), leaflet (maps), joystick, interactive_image, codemirror, json_editor, markdown, chat_message, timeline
      **Input Elements**: All support value binding and event handling
    
      ## Layout Patterns
      ```python
      # Row/column layout with context managers
      with ui.row().classes(&#x27;items-center gap-4&#x27;):
      ui.button(&#x27;Button 1&#x27;)
      ui.button(&#x27;Button 2&#x27;)
    
      with ui.column().classes(&#x27;w-full max-w-lg&#x27;):
      ui.input(&#x27;Name&#x27;)
      ui.textarea(&#x27;Description&#x27;)
    
      # Card containers
      with ui.card().classes(&#x27;w-80&#x27;):
      ui.label(&#x27;Card Title&#x27;).classes(&#x27;text-xl font-bold&#x27;)
      ```
    
      ## Event Handling Patterns
      ```python
      # Click events
      ui.button(&#x27;Click&#x27;, on_click=lambda: ui.notify(&#x27;Clicked&#x27;))
    
      # Input events
      ui.input(&#x27;Type here&#x27;, on_change=lambda e: print(f&#x27;Value: {e.value}&#x27;))
    
      # Keyboard events
      ui.input().on(&#x27;keydown.enter&#x27;, lambda: handle_enter())
    
      # Custom event handlers
      element.on(&#x27;custom-event&#x27;, callback_function)
      ```
    
      ## Data Binding System
      ```python
      # Two-way data binding
      class Data:
      name = &#x27;John&#x27;
      data = Data()
    
      # Bind input to object attribute
      ui.input().bind_value(data, &#x27;name&#x27;)
      ui.label().bind_text_from(data, &#x27;name&#x27;)
    
      # Manual value access
      input_element = ui.input(&#x27;Default&#x27;)
      print(input_element.value)  # Get current value
      input_element.set_value(&#x27;New value&#x27;)  # Set value programmatically
      ```
    
      ## Refreshable UI Pattern
      ```python
      # Refreshable decorator for dynamic content
      @ui.refreshable
      def dynamic_content():
      ui.label(f&#x27;Current time: {datetime.now()}&#x27;)
      for item in data_list:
      ui.label(item.name)
    
      # Refresh the UI section
      dynamic_content.refresh()
    
      # Use in event handlers
      ui.button(&#x27;Update&#x27;, on_click=dynamic_content.refresh)
      ```
    
      ## Page and Routing System
      ```python
      # Define pages with decorators
      @ui.page(&#x27;/&#x27;)
      def index():
      ui.label(&#x27;Home Page&#x27;)
    
      @ui.page(&#x27;/about&#x27;)
      def about():
      ui.label(&#x27;About Page&#x27;)
    
      # Navigation
      ui.link(&#x27;Go to About&#x27;, &#x27;/about&#x27;)
      ui.button(&#x27;Navigate&#x27;, on_click=lambda: ui.navigate.to(&#x27;/about&#x27;))
    
      # Route parameters
      @ui.page(&#x27;/user/{user_id}&#x27;)
      def user_page(user_id: str):
      ui.label(f&#x27;User: {user_id}&#x27;)
      ```
    
      ## App Configuration and Run Options
      ```python
      ui.run(
      host=&#x27;0.0.0.0&#x27;,          # Server host
      port=8080,               # Server port
      title=&#x27;My App&#x27;,          # Browser title
      dark=False,              # Dark mode (None for auto)
      reload=True,             # Auto reload on code changes
      native=False,            # Desktop window mode
      window_size=(1024, 768), # Native window size
      show=True,               # Auto-open browser
      storage_secret=&#x27;key123&#x27;  # Required for user storage
      )
      ```
    
      ## Styling with Tailwind CSS
      ```python
      # Tailwind classes for styling
      ui.label(&#x27;Title&#x27;).classes(&#x27;text-2xl font-bold text-blue-600&#x27;)
      ui.button(&#x27;Primary&#x27;).classes(&#x27;bg-blue-500 hover:bg-blue-700&#x27;)
      ui.card().classes(&#x27;w-full max-w-md shadow-lg&#x27;)
    
      # Responsive design
      ui.row().classes(&#x27;flex-col md:flex-row gap-4&#x27;)
    
      # Custom CSS
      ui.add_css(&#x27;body { background-color: #f0f0f0; }&#x27;)
      ```
    
      ## State Management Patterns
      ```python
      # Global state with refreshable UI
      app_state = {&#x27;counter&#x27;: 0}
    
      @ui.refreshable
      def counter_ui():
      ui.label(f&quot;Count: {app_state[&#x27;counter&#x27;]}&quot;)
      ui.button(&#x27;+1&#x27;, on_click=lambda: increment_counter())
    
      def increment_counter():
      app_state[&#x27;counter&#x27;] += 1
      counter_ui.refresh()
    
      # User session storage
      from nicegui import app
      app.storage.user[&#x27;username&#x27;] = &#x27;john&#x27;
      username = app.storage.user.get(&#x27;username&#x27;, &#x27;anonymous&#x27;)
    
      # Browser local storage
      app.storage.browser[&#x27;preference&#x27;] = &#x27;dark_mode&#x27;
      ```
    
      ## Component Properties and Methods
      ```python
      # Quasar component properties via props()
      ui.input().props(&#x27;outlined dense&#x27;)
      ui.button().props(&#x27;flat round icon=search&#x27;)
    
      # Method chaining pattern
      ui.input(&#x27;Label&#x27;).classes(&#x27;w-full&#x27;).props(&#x27;outlined&#x27;).on(&#x27;keydown.enter&#x27;, handler)
    
      # Component styling
      ui.element(&#x27;div&#x27;).style(&#x27;background: red; padding: 1rem;&#x27;)
      ```
    
      ## Advanced Integration Patterns
      ```python
      # FastAPI integration
      from nicegui import app
      from fastapi import Request
    
      @app.get(&#x27;/api/data&#x27;)
      def api_endpoint():
      return {&#x27;status&#x27;: &#x27;ok&#x27;}
    
      # Middleware usage
      from starlette.middleware.base import BaseHTTPMiddleware
      app.add_middleware(CustomMiddleware)
    
      # JavaScript execution
      ui.run_javascript(&#x27;window.alert(&quot;Hello from Python!&quot;)&#x27;)
    
      # Timer for periodic updates
      ui.timer(1.0, lambda: update_data())  # Every 1 second
      ```
    
      ## Testing and Development
      ```python
      # Component testing with marks
      ui.button(&#x27;Test Button&#x27;).mark(&#x27;test-button&#x27;)
    
      # Pytest integration available via nicegui.testing module
      # Development mode with auto-reload enabled by default
      # Browser dev tools work for debugging rendered HTML/CSS
      ```
    
      ## Best Practices
      - Use `@ui.refreshable` for dynamic content that changes based on state
      - Leverage context managers (`with ui.row():`) for clean layout code
      - Use data binding instead of manual value updates when possible
      - Structure larger apps with multiple pages and separate modules
      - Use Tailwind classes for responsive, maintainable styling
      - Implement proper error handling with `ui.notify()` for user feedback
      - Use `app.storage.user` for session data, `app.storage.browser` for client-side persistence
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753763760284_vel8gqg9o" time="2025/07/29 12:36">
    <content>
      # Tool Skill Memory
    
      ## PlantUML for GUI Design Documentation
    
      PlantUML provides text-based UML diagram creation that&#x27;s excellent for documenting GUI application design, user flows, and component interactions.
    
      ## Core UML Diagram Types for GUI Design
    
      ### 1. State Diagrams (State Charts)
      **Purpose**: Model UI component states and system state transitions triggered by user actions.
    
      **Best for**: Modal dialogs, form validation states, application workflow states, component lifecycle.
    
      **Basic Pattern**:
      ```plantuml
      @startuml
      [*] --&gt; InitialState
      InitialState --&gt; SecondState : user_action
      SecondState --&gt; FinalState : completion_event
      FinalState --&gt; [*]
    
      state InitialState {
      [*] --&gt; SubState1
      SubState1 --&gt; SubState2 : internal_event
      }
      @enduml
      ```
    
      ### 2. Activity Diagrams
      **Purpose**: Model user workflows, business processes, and complex interaction flows.
    
      **Best for**: Multi-step wizards, user onboarding flows, complex business processes, decision-based navigation.
    
      **Basic Pattern**:
      ```plantuml
      @startuml
      start
      :User action;
      if (Condition?) then (yes)
      :Success path;
      else (no)
      :Error path;
      stop
      endif
      :Continue flow;
      stop
      @enduml
      ```
    
      ### 3. Sequence Diagrams
      **Purpose**: Model interactions between UI components, backend services, and user actions over time.
    
      **Best for**: API calls and responses, component communication, event handling chains, asynchronous operations.
    
      **Basic Pattern**:
      ```plantuml
      @startuml
      actor User
      participant &quot;UI Component&quot; as UI
      participant &quot;Service&quot; as Service
      database &quot;Database&quot; as DB
    
      User -&gt; UI : user_action
      UI -&gt; Service : api_call()
      Service -&gt; DB : query()
      DB --&gt; Service : result
      Service --&gt; UI : response
      UI --&gt; User : updated_ui
      @enduml
      ```
    
      ### 4. Use Case Diagrams
      **Purpose**: Model user goals and system functionality from user perspective.
    
      **Best for**: Requirements gathering, feature overview, user role definition, system boundaries.
    
      **Basic Pattern**:
      ```plantuml
      @startuml
      left to right direction
      actor &quot;User Type&quot; as user
      rectangle &quot;System&quot; {
      usecase &quot;Feature 1&quot; as UC1
      usecase &quot;Feature 2&quot; as UC2
      }
      user --&gt; UC1
      user --&gt; UC2
      @enduml
      ```
    
      ## Advanced PlantUML Features
    
      ### Styling and Themes
      ```plantuml
      @startuml
      !theme cerulean-outline
    
      skinparam state {
      BackgroundColor LightBlue
      BorderColor DarkBlue
      FontColor Black
      }
    
      skinparam activity {
      BackgroundColor LightGreen
      BorderColor DarkGreen
      }
      @enduml
      ```
    
      ### Custom Stereotypes and Colors
      ```plantuml
      @startuml
      skinparam state {
      BackgroundColor&lt;&lt;UI&gt;&gt; LightCyan
      BackgroundColor&lt;&lt;Error&gt;&gt; LightPink
      BackgroundColor&lt;&lt;Loading&gt;&gt; LightYellow
      }
    
      state &quot;Login Screen&quot; &lt;&lt;UI&gt;&gt;
      state &quot;Error State&quot; &lt;&lt;Error&gt;&gt;
      @enduml
      ```
    
      ### Notes and Documentation
      ```plantuml
      @startuml
      state LoginForm {
      [*] --&gt; Empty
      Empty --&gt; Filled : user_input
    
      note right of Empty : Initial state when\nform loads
      note bottom of Filled : All validation\nrules active
      }
      @enduml
      ```
    
      ### Hierarchical State Organization
      ```plantuml
      @startuml
      state &quot;Application&quot; {
      state &quot;Authentication Flow&quot; {
      state Login
      state Register
      }
    
      state &quot;Main Application&quot; {
      state Dashboard
      state Settings
      }
      }
      @enduml
      ```
    
      ## Best Practices for GUI Documentation
    
      ### 1. Clear State Naming Conventions
      - Use descriptive names: `WaitingForUserInput` instead of `State1`
      - Include context: `LoginForm_ValidatingCredentials` instead of `Validating`
      - Be consistent across diagrams
    
      ### 2. Document State Transitions with Conditions
      ```plantuml
      @startuml
      state Form {
      Empty --&gt; Filled : user_types_valid_email
      Filled --&gt; Submitting : submit_button_clicked [form_valid]
      Submitting --&gt; Success : api_success
      Submitting --&gt; Error : api_error / show_error_message
      Error --&gt; Filled : user_dismisses_error
      }
      @enduml
      ```
    
      ### 3. Version Control Integration
      ```plantuml
      @startuml
      !define VERSION v2.1.0
      title User Authentication Flow (VERSION)
    
      &#x27; Include modular components
      !include common-styles.puml
      @enduml
      ```
    
      ### 4. Configuration Variables for Flexibility
      ```plantuml
      @startuml
      !$SHOW_DETAILED_STATES = %true()
    
      !if $SHOW_DETAILED_STATES
      state DetailedValidation {
      state CheckFormat
      state CheckLength
      }
      !endif
      @enduml
      ```
    
      ## Common GUI Design Patterns
    
      ### Modal Dialog State Machine
      ```plantuml
      @startuml
      [*] --&gt; Closed
      Closed --&gt; Opening : open_modal()
      Opening --&gt; Opened : animation_complete
      Opened --&gt; Closing : close_modal() / save_data()
      Closing --&gt; Closed : animation_complete
      Opened --&gt; Opened : user_interaction / update_content()
      @enduml
      ```
    
      ### Form Validation Pattern
      ```plantuml
      @startuml
      [*] --&gt; Pristine
      Pristine --&gt; Dirty : user_input
      Dirty --&gt; Validating : on_blur / validate_field()
      Validating --&gt; Valid : validation_success
      Validating --&gt; Invalid : validation_error / show_error()
      Valid --&gt; Dirty : user_input
      Invalid --&gt; Dirty : user_input
      @enduml
      ```
    
      ### Async Operation Pattern
      ```plantuml
      @startuml
      [*] --&gt; Idle
      Idle --&gt; Loading : start_operation()
      Loading --&gt; Success : operation_complete
      Loading --&gt; Error : operation_failed
      Success --&gt; Idle : user_acknowledge
      Error --&gt; Idle : user_retry
      Error --&gt; Loading : auto_retry [retry_count &lt; 3]
      @enduml
      ```
    
      ## Development Workflow Integration
    
      ### Documentation-Driven Development Flow
      1. Create use case diagrams for requirements
      2. Design activity flows for user journeys
      3. Create detailed state diagrams for components
      4. Implement components based on diagrams
      5. Validate implementation against design
      6. Update diagrams or code as needed
    
      ### Living Documentation Strategy
      - Store PlantUML files in version control alongside code
      - Generate diagrams automatically in CI/CD pipeline
      - Embed generated diagrams in technical documentation
      - Link diagrams to design decisions and requirements
      - Use diagrams for code reviews and team collaboration
    
      ### Multi-Diagram Documentation Approach
      For comprehensive GUI documentation:
      - **Use Cases** → Requirements and user goals
      - **Activity Diagrams** → High-level user flows
      - **State Diagrams** → Detailed component behavior
      - **Sequence Diagrams** → Interaction details and timing
    
      ## PlantUML Integration Tools
      - **VS Code**: PlantUML extension for live preview
      - **IntelliJ IDEA**: Built-in PlantUML support
      - **Web Interface**: plantuml.com for quick prototyping
      - **CLI Tools**: Local PlantUML JAR for automation
    
      ## Export and Sharing Options
      - PNG/SVG for documentation embedding
      - PDF for printable specifications
      - ASCII for text-only environments
      - Direct integration with documentation platforms
    
      ## Review and Collaboration Patterns
      ```plantuml
      @startuml
      !procedure $review_state($name, $reviewer, $status)
      state $name {
      note right : Reviewed by: $reviewer\nStatus: $status
      }
      !endprocedure
    
      $review_state(&quot;LoginFlow&quot;, &quot;UI Team&quot;, &quot;Approved&quot;)
      $review_state(&quot;ValidationLogic&quot;, &quot;Backend Team&quot;, &quot;Under Review&quot;)
      @enduml
      ```
    
      ## Key Benefits for GUI Development
      - **Visual Requirements**: Clear communication of complex UI behavior
      - **Implementation Guide**: Step-by-step development roadmap
      - **Testing Reference**: Test cases derived from state transitions
      - **Maintenance Aid**: Understanding existing component behavior
      - **Team Collaboration**: Shared understanding of UI design
      - **Documentation Consistency**: Standardized diagram formats across projects
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753764074240_507yaq4m9" time="2025/07/29 12:41">
    <content>
      # Project-Specific Memory
    
      ## PeiDocker Project Overview
    
      PeiDocker is a sophisticated Docker automation framework that transforms YAML configurations into reproducible containerized environments. The core philosophy is: &quot;Don&#x27;t keep your docker images around, keep the build files!&quot;
    
      ### Design Philosophy
      - **Configuration-driven**: Everything controlled through `user_config.yml` with extensive customization options
      - **Two-stage architecture**: Separates system-level setup (stage-1) from application-level configuration (stage-2)
      - **Flexible storage strategy**: Automatic switching between external volumes and in-image storage
      - **Environment variable substitution**: Docker Compose-style `${VAR:-default}` syntax throughout all configurations
      - **Cross-platform compatibility**: Works consistently across Windows (WSL), Linux, and macOS
    
      ### Development Environment
      - Uses Pixi integrated with pyproject.toml for package management
      - Command line tools: `pei-docker-cli create`, `pei-docker-cli configure`
      - Main CLI entry point: `src/pei_docker/pei.py`
    
      ### Project Structure
      - `src/pei_docker/` - Main package directory
      - `src/pei_docker/gui/` - **EXISTING GUI MODULE** using Textual framework
      - `docs/` - Comprehensive documentation with examples
      - `examples/` - YAML configuration examples for various use cases
    
      ### Current GUI Implementation Status
    
      **IMPORTANT**: There is already a GUI implementation using Textual at `src/pei_docker/gui/` with:
      - Main application: `app.py` with PeiDockerApp class
      - Screen-based navigation (SC-0 to SC-13)
      - CLI command: `pei-docker-gui start` and `pei-docker-gui dev`
      - Project configuration models in `models/config.py`
      - Docker utilities in `utils/docker_utils.py`
      - Startup screen, project setup screen, simple wizard controller implemented
    
      ### Current GUI Architecture
      ```
      src/pei_docker/gui/
      ├── app.py                    # Main application entry point (IMPLEMENTED)
      ├── screens/
      │   ├── startup.py            # System check and welcome screen (IMPLEMENTED)
      │   ├── project_setup.py      # Project directory selection (IMPLEMENTED)
      │   └── simple/
      │       ├── wizard.py         # Wizard controller (IMPLEMENTED)
      │       ├── project_info.py   # Project settings (IMPLEMENTED)
      │       ├── ssh_config.py     # SSH configuration (IMPLEMENTED)
      │       └── summary.py        # Final review and save (IMPLEMENTED)
      ├── models/
      │   └── config.py            # Configuration data models (IMPLEMENTED)
      └── utils/
      ├── docker_utils.py      # Docker integration utilities (IMPLEMENTED)
      └── file_utils.py        # File system utilities (IMPLEMENTED)
      ```
    
      ### GUI Task Requirements from context/tasks/task-gui.md
    
      The task specifies creating additional wizard steps for Simple Mode:
      1. ✅ Project Information (DONE)
      2. ✅ SSH Configuration (DONE)
      3. ⏳ Proxy Configuration
      4. ⏳ Apt Configuration
      5. ⏳ Port Mapping
      6. ⏳ Environment Variables
      7. ⏳ Device (GPU) Configuration
      8. ⏳ Additional Mounts (stage-1 and stage-2)
      9. ⏳ Custom Entry Point
      10. ⏳ Custom Scripts
      11. ✅ Summary/Save (DONE)
    
      ### Configuration Template Reference
      The full configuration template is at `src/pei_docker/templates/config-template-full.yml` with all possible options.
    
      ### Key Implementation Notes
      - GUI only handles stage-1 configuration for most sections (proxy, apt, ssh, ports, env vars, device)
      - Stage-2 configuration requires manual config file editing
      - Uses in-memory configuration until user explicitly saves
      - Supports environment variable substitution: `${VAR:-default}`
      - Docker availability check on startup with graceful degradation
      - Cross-platform file path handling (Windows/Linux/macOS)
    
      ### Development Commands
      ```bash
      # Install dependencies
      pixi install
    
      # Run GUI
      pei-docker-gui start
      pei-docker-gui start --project-dir ./my-project
      pei-docker-gui dev --project-dir ./test --screen sc-1
    
      # Run CLI
      pei-docker-cli create -p ./build
      pei-docker-cli configure -p ./build
      ```
    
      This is critical project context for any GUI development work on PeiDocker.
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753764952813_lxfu86u5n" time="2025/07/29 12:55">
    <content>
      # Project-Specific Memory
    
      ## Available Development Tools for PeiDocker Project
    
      The following tools are available in this development environment for the PeiDocker project:
    
      ### Python Environment &amp; Testing
      - **pixi**: Python environment management tool
      - Testing command: `pixi run -e dev &lt;your test script&gt;`
      - This is the primary package manager for the project
      - Used for installing dependencies and running development tasks
    
      ### Documentation &amp; Diagramming Tools
      - **dot (graphviz)**: Graph visualization and diagramming
      - Useful for creating architecture diagrams, workflow charts
      - Can generate various output formats (PNG, SVG, PDF)
    
      - **plantuml**: UML diagram generation from text
      - Excellent for documenting GUI design workflows
      - Can create state diagrams, sequence diagrams, activity diagrams
      - Particularly useful for documenting the wizard step flows in the GUI
      - Can visualize the screen navigation architecture (SC-0 to SC-13)
    
      ### Testing &amp; Validation Tools
      - **playwright**: Automated web testing framework
      - **pytest-playwright**: Python bindings for Playwright
      - Useful for testing the Textual GUI application
      - Can automate GUI interaction testing
      - May be helpful for testing the wizard workflows and screen transitions
    
      ### Media Processing Tools
      - **imagemagick**: Image processing and manipulation
      - Can be used for creating screenshots, icons, or processing GUI assets
      - Useful for documentation with visual examples
    
      - **ffmpeg**: Video processing and conversion
      - Could be used for creating demo videos of the GUI workflow
      - Useful for documenting complex wizard interactions
    
      ### Development Workflow Integration
      These tools complement the existing PeiDocker GUI development workflow:
      1. Use **pixi** for running the GUI in development mode
      2. Use **plantuml** to document the wizard step flows and screen architecture
      3. Use **playwright** for automated testing of GUI interactions
      4. Use **graphviz** for visualizing the project configuration relationships
      5. Use **imagemagick** for processing any GUI assets or screenshots
    
      ### Specific Use Cases for PeiDocker GUI Development
      - **plantuml**: Document the wizard step state machine and user flows
      - **playwright**: Test the complete wizard workflow from project creation to config save
      - **pixi**: Run GUI in development mode with different screen starting points
      - **graphviz**: Visualize the configuration dependencies between stage-1 and stage-2
      - **imagemagick**: Process any GUI documentation screenshots
    
      This tool ecosystem supports comprehensive GUI development, testing, and documentation for the PeiDocker project.
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753765440275_cgl6w23x0" time="2025/07/29 13:04">
    <content>
      # Tool Skill Memory
    
      ## Testing Web UI Applications with Playwright in Python
    
      Playwright is a powerful end-to-end testing framework for web applications that provides cross-browser automation capabilities. This skill applies to testing any Python-based web UI framework.
    
      ### Installation and Setup
      ```bash
      # Core installation
      pip install playwright pytest-playwright
    
      # Install browser drivers
      playwright install
    
      # Platform-specific drivers (if needed)
      # Linux: sudo apt-get install chromium-chromedriver
      # macOS: brew install chromedriver
      # Windows: choco install chromedriver
      ```
    
      ### Testing Approaches
    
      #### Method 1: Direct Playwright Testing
      ```python
      import asyncio
      import pytest
      from playwright.async_api import async_playwright
      import threading
      import time
    
      @pytest.fixture
      async def web_app():
      &quot;&quot;&quot;Start web app in separate thread&quot;&quot;&quot;
      def run_app():
      # Start your web framework here
      app.run(port=8080, show=False, reload=False)
    
      thread = threading.Thread(target=run_app, daemon=True)
      thread.start()
      time.sleep(2)  # Wait for server startup
      yield &quot;http://localhost:8080&quot;
    
      @pytest.mark.asyncio
      async def test_web_app_with_playwright(web_app):
      async with async_playwright() as p:
      browser = await p.chromium.launch(headless=True)
      page = await browser.new_page()
    
      await page.goto(web_app)
      await page.wait_for_selector(&#x27;text=Expected Content&#x27;)
    
      # Test interactions
      await page.click(&#x27;button:has-text(&quot;Click me&quot;)&#x27;)
      await page.fill(&#x27;input&#x27;, &#x27;Test input&#x27;)
    
      # Verify results
      assert await page.text_content(&#x27;h1&#x27;) == &#x27;Expected Title&#x27;
    
      await browser.close()
      ```
    
      ### Advanced Testing Scenarios
    
      #### Real-time Updates Testing
      ```python
      @pytest.mark.asyncio
      async def test_realtime_updates(web_app):
      async with async_playwright() as p:
      browser = await p.chromium.launch()
      page = await browser.new_page()
    
      await page.goto(web_app)
    
      # Wait for WebSocket connection
      await page.wait_for_function(
      &quot;window.socket &amp;&amp; window.socket.connected&quot;
      )
    
      # Test dynamic updates
      await page.click(&#x27;button:has-text(&quot;Update Counter&quot;)&#x27;)
      await page.wait_for_function(
      &quot;document.querySelector(&#x27;#counter&#x27;).textContent !== &#x27;0&#x27;&quot;
      )
    
      await browser.close()
      ```
    
      #### Cross-Browser Testing
      ```python
      @pytest.mark.parametrize(&quot;browser_name&quot;, [&quot;chromium&quot;, &quot;firefox&quot;, &quot;webkit&quot;])
      @pytest.mark.asyncio
      async def test_cross_browser(web_app, browser_name):
      async with async_playwright() as p:
      browser = await getattr(p, browser_name).launch()
      page = await browser.new_page()
    
      await page.goto(web_app)
      # Perform cross-browser tests
    
      await browser.close()
      ```
    
      ### Screenshot Capabilities
    
      #### Full Page Screenshots
      ```python
      @pytest.mark.asyncio
      async def test_full_page_screenshot(web_app):
      async with async_playwright() as p:
      browser = await p.chromium.launch(headless=True)
      context = await browser.new_context(
      viewport={&quot;width&quot;: 1280, &quot;height&quot;: 720}
      )
      page = await context.new_page()
    
      await page.goto(web_app)
      await page.wait_for_load_state(&quot;networkidle&quot;)
    
      # Full page screenshot
      await page.screenshot(
      path=&quot;full_page_screenshot.png&quot;,
      full_page=True
      )
    
      await browser.close()
      ```
    
      #### Element-Specific Screenshots
      ```python
      # Screenshot specific components
      await page.locator(&#x27;.content-section&#x27;).screenshot(
      path=&quot;content_section.png&quot;
      )
    
      # Screenshot with custom options
      await page.screenshot(
      path=&quot;custom_screenshot.png&quot;,
      full_page=True,
      quality=95,  # For JPEG
      type=&quot;png&quot;,
      clip={       # Specific area
      &quot;x&quot;: 0, &quot;y&quot;: 0,
      &quot;width&quot;: 800, &quot;height&quot;: 600
      }
      )
      ```
    
      #### Screenshots as Base64 Buffer
      ```python
      # In-memory screenshot processing
      screenshot_bytes = await page.screenshot()
      import base64
      screenshot_b64 = base64.b64encode(screenshot_bytes).decode()
      ```
    
      #### Visual Regression Testing
      ```python
      import filecmp
      from pathlib import Path
    
      @pytest.mark.asyncio
      async def test_visual_regression(web_app):
      # Take current screenshot
      await page.screenshot(path=&quot;current_ui.png&quot;, full_page=True)
    
      # Compare with baseline
      if Path(&quot;baseline_ui.png&quot;).exists():
      assert filecmp.cmp(&quot;current_ui.png&quot;, &quot;baseline_ui.png&quot;), \
      &quot;UI has changed compared to baseline&quot;
      else:
      # Establish baseline on first run
      import shutil
      shutil.copy(&quot;current_ui.png&quot;, &quot;baseline_ui.png&quot;)
      ```
    
      ### Configuration and Best Practices
    
      #### pytest Configuration (pytest.ini)
      ```ini
      [tool:pytest]
      asyncio_mode = auto
      testpaths = tests
      addopts =
      --browser chromium
      --headed
      --slowmo 100
      ```
    
      #### Environment Configuration (conftest.py)
      ```python
      @pytest.fixture(scope=&quot;session&quot;)
      async def browser():
      async with async_playwright() as p:
      browser = await p.chromium.launch(
      headless=False,  # Set True for CI/CD
      slow_mo=50      # Debugging aid
      )
      yield browser
      await browser.close()
    
      @pytest.fixture
      async def page(browser):
      page = await browser.new_page()
      yield page
      await page.close()
      ```
    
      #### Screenshot on Test Failure
      ```python
      @pytest.fixture(autouse=True)
      async def screenshot_on_failure(request):
      yield
    
      if request.node.rep_call.failed:
      if hasattr(request.node, &#x27;_page&#x27;):
      page = request.node._page
      screenshot_path = f&quot;failure_{request.node.name}_{int(time.time())}.png&quot;
      await page.screenshot(path=screenshot_path, full_page=True)
      ```
    
      ### Common Challenges and Solutions
    
      #### Dynamic Content Loading
      ```python
      # Wait for specific element
      await page.wait_for_selector(&#x27;.dynamic-content&#x27;)
    
      # Wait for network idle
      await page.wait_for_load_state(&#x27;networkidle&#x27;)
    
      # Wait for custom condition
      await page.wait_for_function(&quot;customCondition()&quot;)
      ```
    
      #### WebSocket Connection Handling
      ```python
      # Ensure WebSocket is connected
      await page.wait_for_function(
      &quot;window.socket &amp;&amp; window.socket.connected&quot;
      )
      ```
    
      ### Mobile Device Testing
      ```python
      # Emulate mobile device
      mobile_context = await browser.new_context(
      viewport={&quot;width&quot;: 375, &quot;height&quot;: 667},  # iPhone SE
      user_agent=&quot;Mozilla/5.0 (iPhone; CPU iPhone OS 14_7 like Mac OS X)&quot;,
      is_mobile=True,
      has_touch=True
      )
      ```
    
      ### Performance Testing
      ```python
      @pytest.mark.asyncio
      async def test_performance(web_app):
      # Start performance monitoring
      await page.evaluate(&quot;performance.mark(&#x27;start&#x27;)&quot;)
    
      await page.goto(web_app)
      await page.wait_for_selector(&#x27;text=Content&#x27;)
    
      # Measure performance
      await page.evaluate(&quot;performance.mark(&#x27;end&#x27;)&quot;)
      duration = await page.evaluate(&quot;&quot;&quot;
      performance.measure(&#x27;test&#x27;, &#x27;start&#x27;, &#x27;end&#x27;);
      performance.getEntriesByName(&#x27;test&#x27;)[0].duration;
      &quot;&quot;&quot;)
    
      assert duration &lt; 2000  # Less than 2 seconds
      ```
    
      ### Best Practices
    
      1. **Consistent Viewport**: Always set fixed viewport for consistent screenshots
      2. **Wait Strategies**: Use appropriate wait strategies for dynamic content
      3. **Resource Management**: Properly close browsers and contexts
      4. **Error Handling**: Implement screenshot capture on test failures
      5. **CI/CD Integration**: Configure headless mode for automated pipelines
      6. **Cross-browser Coverage**: Test across multiple browsers
      7. **Performance Monitoring**: Include performance assertions
      8. **Visual Testing**: Implement screenshot comparison for UI regression
      9. **Mobile Testing**: Include responsive design testing
    
      ### Debugging Tips
      - Use `headless=False` for visual debugging
      - Add `page.pause()` to open Playwright inspector
      - Implement automatic screenshot capture on failures
      - Use `slow_mo` parameter to slow down actions for observation
      - Wait for `networkidle` state before taking screenshots
    
      This comprehensive testing approach with Playwright enables robust end-to-end testing of any web-based UI application across multiple browsers and scenarios.
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753781054147_zo14bko3r" time="2025/07/29 17:24">
    <content>
      # Tool Skill Memory
    
      ## Tracking Unsaved Changes in NiceGUI Applications
    
      This covers comprehensive techniques for implementing &quot;dirty state&quot; tracking in NiceGUI applications to prevent data loss and provide user feedback about unsaved modifications.
    
      ### Core Concepts
    
      **Dirty State Definition**: The condition where form data has been modified by the user but not yet saved to persistent storage. Essential for:
      - Warning users before leaving page with unsaved changes
      - Enabling/disabling save buttons based on modification status
      - Providing visual feedback about unsaved changes
      - Implementing auto-save functionality
    
      **Key Components**: State tracking, user warning, visual feedback, save management
    
      ### NiceGUI Reactive Variables Approach
    
      ```python
      from nicegui import ui
    
      @ui.page(&#x27;/&#x27;)
      def main_page():
      # Create reactive state variables
      form_data, set_form_data = ui.state({
      &#x27;field1&#x27;: &#x27;&#x27;,
      &#x27;field2&#x27;: &#x27;&#x27;,
      &#x27;field3&#x27;: &#x27;&#x27;
      })
    
      # Track if form is dirty
      is_dirty, set_is_dirty = ui.state(False)
      original_data, set_original_data = ui.state({})
    
      def check_dirty():
      dirty = form_data != original_data
      set_is_dirty(dirty)
    
      def save_form():
      # Save logic here
      set_original_data(form_data.copy())
      set_is_dirty(False)
      ui.notify(&#x27;Changes saved!&#x27;)
    
      # Form inputs with change tracking
      ui.input(&#x27;Field 1&#x27;).bind_value(form_data, &#x27;field1&#x27;).on(&#x27;change&#x27;, check_dirty)
      ui.input(&#x27;Field 2&#x27;).bind_value(form_data, &#x27;field2&#x27;).on(&#x27;change&#x27;, check_dirty)
      ui.textarea(&#x27;Field 3&#x27;).bind_value(form_data, &#x27;field3&#x27;).on(&#x27;change&#x27;, check_dirty)
    
      # Save button enabled only when dirty
      ui.button(&#x27;Save&#x27;, on_click=save_form).bind_enabled_from(is_dirty, &#x27;value&#x27;)
    
      # Status indicator
      ui.label().bind_text_from(is_dirty, &#x27;value&#x27;,
      lambda dirty: &#x27;● Unsaved changes&#x27; if dirty else &#x27;✓ All changes saved&#x27;)
      ```
    
      ### Class-Based State Management
    
      ```python
      class FormState:
      def __init__(self):
      self.field1 = &#x27;&#x27;
      self.field2 = &#x27;&#x27;
      self.is_dirty = False
      self.original_state = {}
    
      def mark_dirty(self):
      self.is_dirty = True
    
      def save(self):
      # Save logic
      self.original_state = self.get_current_state()
      self.is_dirty = False
    
      def get_current_state(self):
      return {
      &#x27;field1&#x27;: self.field1,
      &#x27;field2&#x27;: self.field2
      }
    
      def check_changes(self):
      current = self.get_current_state()
      self.is_dirty = current != self.original_state
    
      @ui.page(&#x27;/&#x27;)
      def form_page():
      state = FormState()
    
      # Bind form fields to state object
      ui.input(&#x27;Field 1&#x27;).bind_value(state, &#x27;field1&#x27;).on(&#x27;change&#x27;, state.check_changes)
      ui.input(&#x27;Field 2&#x27;).bind_value(state, &#x27;field2&#x27;).on(&#x27;change&#x27;, state.check_changes)
    
      # UI elements that reflect dirty state
      ui.button(&#x27;Save&#x27;, on_click=state.save).bind_enabled_from(state, &#x27;is_dirty&#x27;)
      ui.label().bind_text_from(state, &#x27;is_dirty&#x27;,
      lambda dirty: &#x27;Unsaved changes&#x27; if dirty else &#x27;Saved&#x27;)
      ```
    
      ### Refreshable UI Pattern
    
      ```python
      form_data = {&#x27;field1&#x27;: &#x27;&#x27;, &#x27;field2&#x27;: &#x27;&#x27;}
      original_data = {}
      is_dirty = False
    
      def check_dirty():
      global is_dirty
      is_dirty = form_data != original_data
      status_display.refresh()
    
      @ui.refreshable
      def status_display():
      if is_dirty:
      ui.label(&#x27;● Unsaved changes&#x27;).classes(&#x27;text-orange-600&#x27;)
      else:
      ui.label(&#x27;✓ All saved&#x27;).classes(&#x27;text-green-600&#x27;)
    
      @ui.refreshable
      def save_button():
      ui.button(&#x27;Save&#x27;, on_click=save_changes).props(&#x27;disable&#x27; if not is_dirty else &#x27;&#x27;)
    
      def save_changes():
      global original_data, is_dirty
      # Save logic here
      original_data = form_data.copy()
      is_dirty = False
      save_button.refresh()
      status_display.refresh()
      ui.notify(&#x27;Changes saved!&#x27;)
      ```
    
      ### Browser-Level Protection
    
      ```python
      @ui.page(&#x27;/&#x27;)
      def protected_form():
      is_dirty, set_is_dirty = ui.state(False)
    
      # JavaScript to warn on page unload
      ui.add_head_html(&quot;&quot;&quot;
      &lt;script&gt;
      let formDirty = false;
    
      function setFormDirty(dirty) {
      formDirty = dirty;
      }
    
      window.addEventListener(&#x27;beforeunload&#x27;, function(e) {
      if (formDirty) {
      e.preventDefault();
      e.returnValue = &#x27;You have unsaved changes. Are you sure you want to leave?&#x27;;
      return e.returnValue;
      }
      });
    
      document.addEventListener(&#x27;submit&#x27;, function() {
      formDirty = false;
      });
      &lt;/script&gt;
      &quot;&quot;&quot;)
    
      def mark_dirty():
      set_is_dirty(True)
      ui.run_javascript(&#x27;setFormDirty(true)&#x27;)
    
      def save_form():
      set_is_dirty(False)
      ui.run_javascript(&#x27;setFormDirty(false)&#x27;)
      ui.notify(&#x27;Saved!&#x27;)
    
      # Form inputs
      ui.input(&#x27;Field 1&#x27;).on(&#x27;change&#x27;, mark_dirty)
      ui.input(&#x27;Field 2&#x27;).on(&#x27;change&#x27;, mark_dirty)
      ui.button(&#x27;Save&#x27;, on_click=save_form)
      ```
    
      ### Advanced Browser Protection with FormTracker
    
      ```python
      ui.add_head_html(&quot;&quot;&quot;
      &lt;script&gt;
      class FormTracker {
      constructor() {
      this.originalData = {};
      this.isDirty = false;
      this.isSubmitting = false;
      this.init();
      }
    
      init() {
      this.captureOriginalState();
    
      document.addEventListener(&#x27;input&#x27;, (e) =&gt; {
      this.checkDirty();
      });
    
      document.addEventListener(&#x27;submit&#x27;, (e) =&gt; {
      this.isSubmitting = true;
      });
    
      window.addEventListener(&#x27;beforeunload&#x27;, (e) =&gt; {
      if (this.isDirty &amp;&amp; !this.isSubmitting) {
      e.preventDefault();
      e.returnValue = &#x27;Changes you made may not be saved.&#x27;;
      return e.returnValue;
      }
      });
      }
    
      captureOriginalState() {
      const inputs = document.querySelectorAll(&#x27;input, textarea, select&#x27;);
      inputs.forEach(input =&gt; {
      this.originalData[input.name || input.id] = input.value;
      });
      }
    
      checkDirty() {
      const inputs = document.querySelectorAll(&#x27;input, textarea, select&#x27;);
      this.isDirty = false;
    
      inputs.forEach(input =&gt; {
      const key = input.name || input.id;
      if (this.originalData[key] !== input.value) {
      this.isDirty = true;
      }
      });
    
      window.postMessage({
      type: &#x27;form-dirty-state&#x27;,
      isDirty: this.isDirty
      }, &#x27;*&#x27;);
      }
    
      markClean() {
      this.captureOriginalState();
      this.isDirty = false;
      this.isSubmitting = false;
      }
      }
    
      const formTracker = new FormTracker();
      window.formTracker = formTracker;
      &lt;/script&gt;
      &quot;&quot;&quot;)
      ```
    
      ### Visual Status Indicators
    
      ```python
      @ui.page(&#x27;/&#x27;)
      def form_with_indicators():
      is_dirty, set_is_dirty = ui.state(False)
    
      def update_status():
      set_is_dirty(True)
    
      def save_changes():
      set_is_dirty(False)
      ui.notify(&#x27;Changes saved!&#x27;, type=&#x27;positive&#x27;)
    
      # Header with status
      with ui.header():
      ui.label(&#x27;Form Title&#x27;)
      ui.space()
      with ui.row():
      ui.icon(&#x27;circle&#x27;, size=&#x27;sm&#x27;).bind_color_from(
      is_dirty, &#x27;value&#x27;,
      lambda dirty: &#x27;orange&#x27; if dirty else &#x27;green&#x27;
      )
      ui.label().bind_text_from(
      is_dirty, &#x27;value&#x27;,
      lambda dirty: &#x27;Unsaved changes&#x27; if dirty else &#x27;All saved&#x27;
      )
    
      # Form inputs
      ui.input(&#x27;Field 1&#x27;).on(&#x27;change&#x27;, update_status)
      ui.textarea(&#x27;Field 2&#x27;).on(&#x27;change&#x27;, update_status)
    
      # Save button with visual state
      ui.button(&#x27;Save Changes&#x27;, on_click=save_changes).bind_enabled_from(is_dirty, &#x27;value&#x27;)
      ```
    
      ### Tab-Based Forms with Individual Status
    
      ```python
      @ui.page(&#x27;/&#x27;)
      def tabbed_form():
      # Track dirty state for each tab
      tab_states = {
      &#x27;tab1&#x27;: ui.state(False),
      &#x27;tab2&#x27;: ui.state(False),
      &#x27;tab3&#x27;: ui.state(False)
      }
    
      def mark_tab_dirty(tab_name):
      tab_states[tab_name][1](True)
    
      def get_tab_label(tab_name, base_label):
      is_dirty = tab_states[tab_name][0]
      return f&quot;{base_label} {&#x27;●&#x27; if is_dirty else &#x27;&#x27;}&quot;
    
      with ui.tabs() as tabs:
      tab1 = ui.tab(&#x27;tab1&#x27;)
      tab2 = ui.tab(&#x27;tab2&#x27;)
      tab3 = ui.tab(&#x27;tab3&#x27;)
    
      with ui.tab_panels(tabs, value=&#x27;tab1&#x27;):
      with ui.tab_panel(&#x27;tab1&#x27;):
      ui.input(&#x27;Field A&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab1&#x27;))
      ui.input(&#x27;Field B&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab1&#x27;))
    
      with ui.tab_panel(&#x27;tab2&#x27;):
      ui.input(&#x27;Field C&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab2&#x27;))
      ui.number(&#x27;Field D&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab2&#x27;))
    
      with ui.tab_panel(&#x27;tab3&#x27;):
      ui.textarea(&#x27;Field E&#x27;).on(&#x27;change&#x27;, lambda: mark_tab_dirty(&#x27;tab3&#x27;))
    
      # Update tab labels to show dirty state
      @ui.refreshable
      def update_tab_labels():
      tab1.set_text(get_tab_label(&#x27;tab1&#x27;, &#x27;Tab 1&#x27;))
      tab2.set_text(get_tab_label(&#x27;tab2&#x27;, &#x27;Tab 2&#x27;))
      tab3.set_text(get_tab_label(&#x27;tab3&#x27;, &#x27;Tab 3&#x27;))
      ```
    
      ### Performance Optimization with Debouncing
    
      ```python
      import asyncio
    
      @ui.page(&#x27;/&#x27;)
      def optimized_form():
      debounce_timer = None
    
      async def debounced_check():
      nonlocal debounce_timer
      if debounce_timer:
      debounce_timer.cancel()
    
      debounce_timer = asyncio.create_task(asyncio.sleep(0.5))
      try:
      await debounce_timer
      # Perform expensive state check here
      check_form_state()
      except asyncio.CancelledError:
      pass
    
      def check_form_state():
      # State checking logic
      pass
    
      ui.input(&#x27;Search&#x27;).on(&#x27;change&#x27;, lambda: asyncio.create_task(debounced_check()))
      ```
    
      ### Error Handling Pattern
    
      ```python
      @ui.page(&#x27;/&#x27;)
      def robust_form():
      def save_with_validation():
      try:
      if not validate_form():
      ui.notify(&#x27;Please fix validation errors&#x27;, type=&#x27;negative&#x27;)
      return
    
      save_data()
      ui.notify(&#x27;Saved successfully!&#x27;, type=&#x27;positive&#x27;)
    
      except Exception as e:
      ui.notify(f&#x27;Save failed: {str(e)}&#x27;, type=&#x27;negative&#x27;)
    
      def validate_form():
      # Validation logic
      return True
    
      def save_data():
      # Save logic
      pass
      ```
    
      ### Memory Management
    
      ```python
      from nicegui import ui, app
    
      @ui.page(&#x27;/&#x27;)
      def memory_conscious_form():
      # Use app.storage for persistent state
      if &#x27;form_data&#x27; not in app.storage.user:
      app.storage.user[&#x27;form_data&#x27;] = {}
    
      # Clean up on page exit
      def cleanup():
      # Clean up resources
      pass
    
      # Register cleanup
      ui.context.client.on_disconnect(cleanup)
      ```
    
      ### Best Practices
    
      1. **Performance**: Use debounce for input events, leverage reactive variables, minimize DOM updates
      2. **Error Handling**: Validate before save, provide clear error messages, handle exceptions gracefully
      3. **Memory Management**: Clean up resources, use app.storage for persistence
      4. **User Experience**: Provide visual feedback, warn before data loss, enable/disable actions appropriately
      5. **Browser Compatibility**: Test beforeunload behavior across browsers
    
      ### Common Pitfalls
    
      - Not clearing dirty state on successful save
      - Excessive event handlers without debouncing
      - Memory leaks from unhandled event listeners
      - Race conditions in async operations
      - Not handling form submission states properly
    
      ### Implementation Checklist
    
      - [ ] Choose appropriate state tracking method
      - [ ] Implement change detection for all form fields
      - [ ] Add browser-level protection against data loss
      - [ ] Provide visual feedback for unsaved changes
      - [ ] Handle form submission and state reset
      - [ ] Add validation and error handling
      - [ ] Test edge cases (refresh, navigation, etc.)
      - [ ] Optimize performance for large forms
    
      This comprehensive approach ensures robust unsaved change tracking in any NiceGUI application, preventing data loss and providing excellent user experience.
    </content>
    <tags>#其他</tags>
  </item>
  <item id="mem_1753783371936_khz73vql1" time="2025/07/29 18:02">
    <content>
      # Tool Skill Memory
    
      ## File Handling Best Practices in NiceGUI Applications
    
      ### Architectural Approach: Server-Side vs Client-Side
    
      **Recommended Approach: Server-Side Processing**
      - Files are created and managed on server filesystem
      - Python handles all file operations and zipping
      - Files are served to browser for download
      - Maintains security, follows NiceGUI&#x27;s backend-first philosophy
    
      **Why Server-Side is Preferred:**
      - Security isolation and input validation
      - Alignment with NiceGUI/FastAPI architecture
      - Better error handling and resource management
      - Cross-platform compatibility and scalability
    
      ### Core Implementation Patterns
    
      #### Basic Server-Side File Operations
      ```python
      import tempfile
      import zipfile
      from pathlib import Path
      from nicegui import app, ui
    
      def create_workspace():
      &quot;&quot;&quot;Create temporary directory for user modifications&quot;&quot;&quot;
      temp_dir = Path(tempfile.mkdtemp())
      app.storage.user[&#x27;workspace_dir&#x27;] = str(temp_dir)
    
      # Initialize structure
      (temp_dir / &#x27;config&#x27;).mkdir()
      (temp_dir / &#x27;data&#x27;).mkdir()
    
      ui.notify(&#x27;Workspace created&#x27;, type=&#x27;positive&#x27;)
      return temp_dir
    
      def zip_and_download():
      &quot;&quot;&quot;Create zip file and trigger download&quot;&quot;&quot;
      workspace_dir = Path(app.storage.user.get(&#x27;workspace_dir&#x27;, &#x27;&#x27;))
    
      if not workspace_dir.exists():
      ui.notify(&#x27;No workspace found&#x27;, type=&#x27;negative&#x27;)
      return
    
      # Create zip file
      zip_path = workspace_dir.parent / f&quot;{workspace_dir.name}.zip&quot;
    
      with zipfile.ZipFile(zip_path, &#x27;w&#x27;, zipfile.ZIP_DEFLATED) as zipf:
      for file_path in workspace_dir.rglob(&#x27;*&#x27;):
      if file_path.is_file():
      arcname = file_path.relative_to(workspace_dir)
      zipf.write(file_path, arcname)
    
      # Make available for download
      app.add_static_file(&#x27;/download.zip&#x27;, str(zip_path))
      ui.download(&#x27;/download.zip&#x27;, f&#x27;workspace-{workspace_dir.name}.zip&#x27;)
      ```
    
      #### Advanced Workspace Management Pattern
      ```python
      import shutil
      from datetime import datetime, timedelta
    
      class WorkspaceManager:
      def __init__(self):
      self.base_dir = Path(tempfile.gettempdir()) / &#x27;app_workspaces&#x27;
      self.base_dir.mkdir(exist_ok=True)
    
      def create_workspace(self, user_id: str) -&gt; Path:
      timestamp = datetime.now().strftime(&#x27;%Y%m%d_%H%M%S&#x27;)
      workspace_dir = self.base_dir / f&quot;user_{user_id}_{timestamp}&quot;
      workspace_dir.mkdir(parents=True)
    
      # Initialize structure
      self._init_workspace_structure(workspace_dir)
      return workspace_dir
    
      def cleanup_old_workspaces(self, max_age_hours: int = 24):
      cutoff_time = datetime.now() - timedelta(hours=max_age_hours)
    
      for workspace in self.base_dir.iterdir():
      if workspace.is_dir() and workspace.stat().st_mtime &lt; cutoff_time.timestamp():
      shutil.rmtree(workspace)
    
      # Usage pattern
      workspace_manager = WorkspaceManager()
      app.on_startup(lambda: workspace_manager.cleanup_old_workspaces())
      ```
    
      ### NiceGUI Storage Options
    
      **Choose appropriate storage based on data lifetime:**
      ```python
      # User storage - persistent across sessions
      app.storage.user[&#x27;workspace_dir&#x27;] = str(workspace_path)
    
      # Tab storage - session-specific, more secure
      app.storage.tab[&#x27;temp_workspace&#x27;] = str(temp_path)
    
      # Client storage - per-connection
      app.storage.client[&#x27;active_files&#x27;] = file_list
    
      # Browser storage - stored in browser localStorage
      app.storage.browser[&#x27;user_settings&#x27;] = settings_dict
      ```
    
      ### Error Handling Pattern
      ```python
      async def safe_file_operation():
      try:
      workspace_dir = Path(app.storage.user.get(&#x27;workspace_dir&#x27;))
    
      if not workspace_dir.exists():
      raise FileNotFoundError(&quot;Workspace not found&quot;)
    
      # Perform file operations
      result = await some_file_operation(workspace_dir)
      ui.notify(&#x27;Operation completed successfully&#x27;, type=&#x27;positive&#x27;)
      return result
    
      except FileNotFoundError as e:
      ui.notify(f&#x27;File error: {e}&#x27;, type=&#x27;negative&#x27;)
      except PermissionError as e:
      ui.notify(&#x27;Permission denied&#x27;, type=&#x27;negative&#x27;)
      except Exception as e:
      ui.notify(f&#x27;Unexpected error: {e}&#x27;, type=&#x27;negative&#x27;)
      ```
    
      ### Security Best Practices
    
      #### Path Validation
      ```python
      def validate_file_path(user_path: str, base_dir: Path) -&gt; bool:
      &quot;&quot;&quot;Prevent directory traversal attacks&quot;&quot;&quot;
      try:
      resolved_path = (base_dir / user_path).resolve()
      return base_dir.resolve() in resolved_path.parents
      except:
      return False
      ```
    
      #### File Size and Type Restrictions
      ```python
      MAX_WORKSPACE_SIZE = 100 * 1024 * 1024  # 100MB
      ALLOWED_EXTENSIONS = {&#x27;.txt&#x27;, &#x27;.md&#x27;, &#x27;.json&#x27;, &#x27;.yaml&#x27;, &#x27;.yml&#x27;, &#x27;.py&#x27;}
    
      def check_workspace_size(workspace_dir: Path) -&gt; bool:
      total_size = sum(f.stat().st_size for f in workspace_dir.rglob(&#x27;*&#x27;) if f.is_file())
      return total_size &lt;= MAX_WORKSPACE_SIZE
    
      def is_allowed_file(file_path: Path) -&gt; bool:
      return file_path.suffix.lower() in ALLOWED_EXTENSIONS
      ```
    
      ### Download Implementation Patterns
    
      #### Static File Serving
      ```python
      # Add file to static files and trigger download
      app.add_static_file(&#x27;/download/file.zip&#x27;, str(zip_path))
      ui.download(&#x27;/download/file.zip&#x27;, &#x27;filename.zip&#x27;)
      ```
    
      #### Dynamic File Generation
      ```python
      def generate_and_download():
      # Generate content dynamically
      content = generate_file_content()
    
      # Write to temporary file
      temp_file = Path(tempfile.mktemp(suffix=&#x27;.txt&#x27;))
      temp_file.write_text(content)
    
      # Serve for download
      app.add_static_file(&#x27;/generated.txt&#x27;, str(temp_file))
      ui.download(&#x27;/generated.txt&#x27;, &#x27;generated_file.txt&#x27;)
      ```
    
      ### Deployment Considerations
    
      #### Local Development
      - Use temporary directories for file operations
      - Implement cleanup routines for development
      - Simple single-user file management
    
      #### Production Deployment
      - Consider persistent storage solutions
      - Implement proper user authentication
      - Add rate limiting and resource quotas
      - Use container-friendly storage patterns
    
      #### Docker Deployment
      ```python
      # Use environment variables for configuration
      WORKSPACE_BASE = Path(os.environ.get(&#x27;WORKSPACE_DIR&#x27;, &#x27;/app/workspaces&#x27;))
      WORKSPACE_BASE.mkdir(exist_ok=True)
      ```
    
      ### Key Principles
    
      1. **Always use server-side file processing** for security and architecture alignment
      2. **Choose appropriate NiceGUI storage** based on data lifetime requirements
      3. **Implement proper error handling** with user-friendly feedback
      4. **Validate file paths and types** to prevent security vulnerabilities
      5. **Clean up temporary files** to prevent resource exhaustion
      6. **Use Path objects** for cross-platform file system operations
      7. **Provide clear user feedback** for all file operations
    
      ### Common Anti-Patterns to Avoid
    
      - Storing sensitive data in client-side storage
      - Not validating file paths (directory traversal vulnerability)
      - Missing cleanup routines for temporary files
      - Using inappropriate storage types for data lifetime
      - Poor error handling without user feedback
      - Client-side file processing for complex operations
    
      This approach ensures secure, reliable, and maintainable file handling in any NiceGUI application while following framework best practices.
    </content>
    <tags>#其他</tags>
  </item>
</memory>