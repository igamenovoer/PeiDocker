# Feature Plan: Configure `--with-merged` (Merged Docker build)

## Goal

Add a `--with-merged` flag to `pei-docker-cli configure` that generates three extra files in the project directory:
- `merged.Dockerfile` – a standalone, self-contained multi-stage Dockerfile that performs both stage-1 and stage-2 steps in one file (no dependency on other Dockerfiles).
- `merged.env` – an env file containing all configurable build-time args (for both stages) as KEY=VALUE pairs.
- `build-merged.sh` – a portable script that sources `merged.env` and builds the final stage-2 image using only `merged.Dockerfile` (no docker compose required).

This enables users to build the final stage-2 image via a single plain `docker build` invocation, while stage-1 is built as an internal temporary stage inside `merged.Dockerfile`.

## High-Level Design

- Extend `pei.py:configure` with a new Click flag `--with-merged` (bool, default False).
- During configure, after we produce the resolved `docker-compose.yml`, derive the fully resolved build-arg sets for `services.stage-1` and `services.stage-2` from the processed compose object.
- Keep `src/pei_docker/pei.py` and `src/pei_docker/config_processor.py` short: implement generation in a new module `src/pei_docker/merge_build.py` with a single entry `generate_merged_build(project_dir: str, out_compose: DictConfig) -> None`. The CLI will just call this function when `--with-merged` is set.
- Generate `merged.Dockerfile` programmatically by composing the logic from both `stage-1.Dockerfile` and `stage-2.Dockerfile` into one multi-stage file:
  - Stage `stage1`: `FROM ${BASE_IMAGE_1}` and then run all stage-1 steps (COPY/ADD stage-1 internals, dos2unix, chmod, setup-env, install essentials, profile.d, custom-on-build, setup-users, cleanup).
  - Final stage: `FROM stage1` and then run all stage-2 steps (COPY/ADD stage-2 internals, dos2unix, chmod, setup-env, create-dirs, install essentials, profile.d, custom-on-build, setup-users, cleanup, entrypoint).
  - Keep the same script execution order and ENV/ARG wiring as templates, using two independent arg sets for stage-1 and stage-2.
- Write `merged.env` with all build-time args required by both stages (see below). Users may tweak this file and re-run the build without re-configure.
- Write `build-merged.sh` which performs one docker build using `merged.Dockerfile`, sources `merged.env` to export all build args into the environment, and passes them to `docker build` via `--build-arg VAR` flags (name-only; Docker picks values from environment). It tags the final stage-2 image. Add `--add-host=host.docker.internal:host-gateway` for proxy support.

## File Outputs (generated in project dir)

- `merged.Dockerfile`
  - A single multi-stage Dockerfile, generated by merging the package templates for stage-1 and stage-2 into one file.
  - Build args are split into two groups with non-conflicting names where applicable:
    - Stage-1 args: `BASE_IMAGE_1`, `PEI_STAGE_HOST_DIR_1`, `PEI_STAGE_DIR_1`, `PEI_HTTP_PROXY_1`, `PEI_HTTPS_PROXY_1`, `WITH_ESSENTIAL_APPS_1`, `WITH_SSH`, APT related args, etc.
    - Stage-2 args: `PEI_STAGE_HOST_DIR_2`, `PEI_STAGE_DIR_2`, `PEI_HTTP_PROXY_2`, `PEI_HTTPS_PROXY_2`, `WITH_ESSENTIAL_APPS_2`, and others.
  - Shared arg names (e.g., `ENABLE_GLOBAL_PROXY`) can remain common; both stages will use the same value.

- `merged.env`
  - Contains all variables consumed as build args by `merged.Dockerfile`.
  - Format: POSIX-compatible KEY='value' lines (values quoted; single quotes escaped).
  - Includes both stage-1 and stage-2 args. For example:
    - Stage-1: `BASE_IMAGE_1=...`, `PEI_STAGE_HOST_DIR_1=...`, `PEI_STAGE_DIR_1=...`, `PEI_HTTP_PROXY_1=...`, `PEI_HTTPS_PROXY_1=...`, `WITH_SSH=...`, `SSH_USER_NAME=...`, `SSH_USER_PASSWORD=...`, `SSH_USER_UID=...`, `SSH_PUBKEY_FILE=...`, `SSH_PRIVKEY_FILE=...`, `SSH_CONTAINER_PORT=...`, `APT_SOURCE_FILE=...`, `KEEP_APT_SOURCE_FILE=...`, `APT_USE_PROXY=...`, `APT_KEEP_PROXY=...`, `PEI_BAKE_ENV_STAGE_1=...`, etc.
    - Stage-2: `PEI_STAGE_HOST_DIR_2=...`, `PEI_STAGE_DIR_2=...`, `PEI_HTTP_PROXY_2=...`, `PEI_HTTPS_PROXY_2=...`, `ENABLE_GLOBAL_PROXY=...`, `REMOVE_GLOBAL_PROXY_AFTER_BUILD=...`, path prefixes, etc.
  - Values are derived from the resolved compose object at configure time. Users can edit this file before running the build.

- `build-merged.sh`
  - Shebang: `#!/usr/bin/env bash`
  - Safety: `set -euo pipefail`
  - Variables injected at generation time (literal strings from resolved compose/config):
    - `PROJECT_DIR` set to script directory.
    - `STAGE2_IMAGE_NAME` from `services.stage-2.image`.
  - Uses the env file:
    - `set -a; source "$PROJECT_DIR/merged.env"; set +a`
    - Build with `--build-arg VAR` flags for all variables present in `merged.env` that the merged Dockerfile expects (names only; Docker reads values from environment).
  - Commands:
    - Single command:
      - `docker build -f "$PROJECT_DIR/merged.Dockerfile" -t "$STAGE2_IMAGE_NAME" --add-host=host.docker.internal:host-gateway \` followed by one `--build-arg KEY` per arg from both stages (names only), then `"$PROJECT_DIR"`.

## CLI Changes

- In `src/pei_docker/pei.py` update `configure` signature:
  - Add `@click.option('--with-merged', is_flag=True, default=False, help='Generate merged.Dockerfile and build-merged.sh')`.
  - Update function `def configure(project_dir: str, config: str, full_compose: bool, with_merge: bool) -> None:`.
  - After writing `docker-compose.yml`, if `with_merge` is True, call a helper to generate the two files.

## Implementation Details

1) Extract resolved values
- After `proc.process(remove_extra=not full_compose)` returns `out_compose`:
  - stage-1: `svc1 = out_compose['services']['stage-1']`
  - stage-2: `svc2 = out_compose['services']['stage-2']`
  - `img1 = svc1.get('image')`, `img2 = svc2.get('image')`
  - `args1 = (svc1.get('build') or {}).get('args') or {}`
  - `args2 = (svc2.get('build') or {}).get('args') or {}`
  - These maps are fully resolved because we resolved the compose template before writing it.

2) Write merged.Dockerfile (standalone, multi-stage)
- Read the package templates `project_files/stage-1.Dockerfile` and `project_files/stage-2.Dockerfile` (not used at build time; only used to generate merged content).
- Build a combined Dockerfile string:
  - Replace the first line `ARG BASE_IMAGE` and `FROM ${BASE_IMAGE}` in stage-1 with `ARG BASE_IMAGE_1` and `FROM ${BASE_IMAGE_1} AS stage1`.
  - Keep the rest of stage-1 sections intact (ADD, RUN, ENV, etc.). Ensure references use `PEI_STAGE_*_1` variables.
  - Append a new stage derived from stage-2 template where `FROM ${BASE_IMAGE}` is replaced with `FROM stage1 AS final` and any `ARG BASE_IMAGE` declaration is removed.
  - Keep the rest of stage-2 sections intact (ADD, RUN, ENV, ENTRYPOINT), using `PEI_STAGE_*_2` variables.
  - Ensure there is no reliance on external Dockerfiles; the final file composes both stages.

3) Write build-merged.sh
- Generate a single `docker build` command consuming both arg sets. Quote values as described below and add `--add-host=host.docker.internal:host-gateway`.
- Mark as executable: `os.chmod(path, 0o755)`.

4) Error handling
- If any required section is missing, log a clear message and skip generation.
- If stage-1/stage-2 Dockerfiles are missing, warn and skip or fallback to package templates.

5) Quoting rules for build args
- For each arg value V:
  - Convert to string via `str(V)`.
  - Escape single quotes: `V.replace("'", "'\\''")`.
  - Emit as: `--build-arg KEY='escaped'` (even if empty, pass as empty string `'`')` to avoid shell word-splitting issues).

6) Host/Container path consistency
- `PEI_STAGE_HOST_DIR_*` must point to `project_dir/installation/stage-*` (already in resolved `args*`).
- `PEI_STAGE_DIR_*` must remain `/pei-from-host/stage-*` (container path).
- No compose volumes are required at build time; the Dockerfiles perform `ADD` of `PEI_STAGE_HOST_DIR_*`.

7) Cleanup behavior
- Default: remove temp stage-1 image after successful stage-2 build.
- Allow opt-out via env var in script: if `KEEP_TMP_STAGE1=1`, skip cleanup.

## Pseudocode (generation inside configure)

```python
if with_merge:
    svc1 = out_compose['services'].get('stage-1', {})
    svc2 = out_compose['services'].get('stage-2', {})
    img1 = svc1.get('image'); img2 = svc2.get('image')
    args1 = (svc1.get('build') or {}).get('args') or {}
    args2 = (svc2.get('build') or {}).get('args') or {}

    # 1) Write merged.Dockerfile (standalone)
    merged_df = os.path.join(project_dir, 'merged.Dockerfile')
    df1 = Path(pkg_root) / 'project_files' / 'stage-1.Dockerfile'
    df2 = Path(pkg_root) / 'project_files' / 'stage-2.Dockerfile'
    content1 = Path(df1).read_text()
    content2 = Path(df2).read_text()
    content1 = content1.replace('ARG BASE_IMAGE', 'ARG BASE_IMAGE_1')
    content1 = re.sub(r'^FROM\s+\$\{BASE_IMAGE\}', 'FROM ${BASE_IMAGE_1} AS stage1', content1, flags=re.M)
    content2 = re.sub(r'^ARG\s+BASE_IMAGE\s*\n', '', content2, flags=re.M)  # drop BASE_IMAGE arg
    content2 = re.sub(r'^FROM\s+\$\{BASE_IMAGE\}.*$', 'FROM stage1 AS final', content2, flags=re.M)
    Path(merged_df).write_text(content1 + '\n\n' + content2)

    # 2) Write merged.env (all build args)
    def quote_env(v: Any) -> str:
        s = str(v)
        return "'" + s.replace("'", "'\\''") + "'"

    env_lines: list[str] = []
    def add_env_from_args(prefix_map: dict[str, Any], rename: dict[str, str] | None = None) -> None:
        for k, v in (prefix_map or {}).items():
            key = (rename or {}).get(k, k)
            if key == 'BASE_IMAGE':
                key = 'BASE_IMAGE_1'  # merged uses BASE_IMAGE_1
            env_lines.append(f"{key}={quote_env(v)}")

    add_env_from_args(args1)
    add_env_from_args(args2)
    (Path(project_dir) / 'merged.env').write_text("\n".join(env_lines) + "\n")

    # 3) Write build-merged.sh (single docker build)
    def emit_args(args: dict[str, Any]) -> str:
        names = []
        for k in (args or {}).keys():
            if k == 'BASE_IMAGE':
                k = 'BASE_IMAGE_1'
            names.append(f"  --build-arg {k} \\")
        return "\n".join(names)

    stage1_arg_names = emit_args(args1)
    stage2_arg_names = emit_args(args2)
    script = f"""#!/usr/bin/env bash
set -euo pipefail
PROJECT_DIR=$(cd "$(dirname "$0")" && pwd)
STAGE2_IMAGE_NAME='{img2}'
set -a
source "$PROJECT_DIR/merged.env"
set +a
docker build \
  -f "$PROJECT_DIR/merged.Dockerfile" \
  -t "$STAGE2_IMAGE_NAME" \
  --add-host=host.docker.internal:host-gateway \
{stage1_arg_names}
{stage2_arg_names}
  "$PROJECT_DIR"

echo "[merge] Done. Final image: $STAGE2_IMAGE_NAME"
"""
    path_sh = os.path.join(project_dir, 'build-merged.sh')
    with open(path_sh, 'w') as f:
        f.write(script)
    os.chmod(path_sh, 0o755)
```

## Testing Strategy

- Unit-light, integration-heavy (manual) for now:
  - Run `pei-docker-cli create -p demo && cd demo && pei-docker-cli configure --with-merged`.
  - Inspect generated `merged.Dockerfile` and `build-merged.sh`.
- Build with `./build-merged.sh` and ensure it produces the same stage-2 image tag as in compose.
- Verify proxy and APT args are present for stage-1, and stage-2 receives proper args and overrides BASE_IMAGE.
- Modify `merged.env` (e.g., switch proxies, paths) and rebuild to confirm the script picks up changes.

## Documentation Updates

- docs/index.md: Add a short section under Troubleshooting/Advanced: “Build without docker compose: build-merged.sh”.
- docs/cli_reference.md: Update configure command options to include `--with-merged`.
- docs/build-internals.md: Note the merged build path as an alternative.

## Acceptance Criteria

- `pei-docker-cli configure --with-merged` writes merged.Dockerfile, merged.env, and build-merged.sh to the project directory.
- `build-merged.sh` successfully builds stage-1 as a temp image and then stage-2, without docker compose.
- All needed build args are present and quoted correctly; stage-2’s `BASE_IMAGE` is the temp stage-1 tag.
- No changes to existing compose-based flow when `--with-merged` is not provided.
- Users can edit merged.env to customize values without re-running configure.
Code placement to avoid bloat

- New module: `src/pei_docker/merge_build.py`
  - Public API: `generate_merged_build(project_dir: str, out_compose: DictConfig) -> None`
  - Internals (typed helpers):
    - `_compose_merged_dockerfile(pkg_root: str) -> str`
    - `_collect_build_args(out_compose: DictConfig) -> tuple[dict[str, Any], dict[str, Any], str]` (returns stage1 args, stage2 args, stage2 image name)
    - `_write_text(path: str, content: str) -> None` (ensures dirs)
    - `_write_merged_env(path: str, args1: dict[str, Any], args2: dict[str, Any]) -> None`
    - `_write_build_script(path: str, stage2_image: str, args1: dict[str, Any], args2: dict[str, Any]) -> None`
  - `pei.py` change remains minimal: after writing compose, `if with_merge: generate_merged_build(project_dir, out_compose)`.
