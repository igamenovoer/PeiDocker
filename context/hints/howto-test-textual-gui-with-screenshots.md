# Automated GUI Screenshot Testing with pytest-textual-snapshot

This guide documents practical experience implementing automated screenshot testing for Textual GUI applications using pytest-textual-snapshot, based on creating a test pipeline for PeiDocker GUI screens.

## Why Automated Screenshot Testing?

Screenshot testing provides:
- **Visual regression detection** - Catch unintended UI changes
- **Documentation generation** - Auto-generate visual docs
- **CI/CD integration** - Headless testing in pipelines
- **Design verification** - Compare implementation vs specs
- **Cross-platform consistency** - Ensure UI looks the same everywhere

## Core Implementation Strategy

### 1. Project Structure Setup

```
tests/
├── autotest/
│   ├── __init__.py
│   ├── test_gui_screenshots.py      # Main test file
│   ├── gui_test_app.py             # Testable wrapper
│   ├── __snapshots__/              # Auto-generated by pytest
│   │   └── test_gui_screenshots/
│   │       ├── TestClass.test_method.svg
│   │       └── ...
│   └── README.md                   # Test documentation
└── ...

tmp/output/gui-screenshots/         # Final organized outputs
├── sc-0-startup-screen.svg
├── sc-1-project-setup-screen.svg
└── ...
```

### 2. Dependencies and Environment

```bash
# Install required testing dependencies
pixi add --pyproject pytest-textual-snapshot

# Verify development environment
pixi run -e dev python -c "import pytest_textual_snapshot"
```

**Key Insight**: Use pixi development environment (`-e dev`) for consistent testing environment across team members.

## Creating the Testable GUI Wrapper

The biggest challenge is making your GUI app testable by pytest-textual-snapshot. Create a standalone wrapper:

```python
# tests/autotest/gui_test_app.py
#!/usr/bin/env python3
"""
Test application wrapper for GUI screenshot capture.
This makes the main GUI app testable by pytest-textual-snapshot.
"""

import sys
from pathlib import Path

# Critical: Add src directory to Python path
sys.path.insert(0, str(Path(__file__).parent.parent.parent / "src"))

from pei_docker.gui.app import PeiDockerApp

if __name__ == "__main__":
    app = PeiDockerApp()
    app.run()
```

**Key Insights**:
- Must be executable as standalone Python script
- Requires proper import path setup for your package
- File path must be absolute for pytest-textual-snapshot
- Keep it simple - just import and run your main app

## Main Test Implementation

```python
# tests/autotest/test_gui_screenshots.py
import pytest
from pathlib import Path
from typing import Any

class TestGUIScreenshots:
    """Test class for capturing GUI screenshots using pytest-textual-snapshot."""
    
    @pytest.fixture(autouse=True)
    def setup_screenshots_dir(self) -> None:
        """Ensure output directory exists."""
        screenshots_path = Path("tmp/output/gui-screenshots")
        screenshots_path.mkdir(parents=True, exist_ok=True)
    
    def test_sc0_startup_screen(self, snap_compare: Any) -> None:
        """Test SC-0: Application Startup Screen screenshot capture."""
        # Use permanent test app file (not temporary)
        test_app_path = Path(__file__).parent / "gui_test_app.py"
        
        # Capture with system validation delay
        assert snap_compare(
            str(test_app_path), 
            terminal_size=(120, 40),
            press=["wait:3000"]  # Critical: Wait for system checks
        )
        
        # Copy to organized output directory
        self._copy_snapshot_to_screenshots("sc-0-startup-screen")
    
    def test_sc1_project_setup_screen(self, snap_compare: Any) -> None:
        """Test SC-1: Project Directory Selection Screen screenshot capture."""
        test_app_path = Path(__file__).parent / "gui_test_app.py"
        
        # Navigate between screens
        assert snap_compare(
            str(test_app_path),
            terminal_size=(120, 40), 
            press=["wait:3000", "enter", "wait:1000"]  # Wait → Navigate → Wait
        )
        
        self._copy_snapshot_to_screenshots("sc-1-project-setup-screen")
    
    def _copy_snapshot_to_screenshots(self, filename_prefix: str) -> None:
        """Copy generated snapshot to organized output directory."""
        snapshots_dir = Path("tests/__snapshots__")
        screenshots_dir = Path("tmp/output/gui-screenshots")
        
        if snapshots_dir.exists():
            # Find most recent snapshot (pytest generates with timestamp)
            snapshot_files = list(snapshots_dir.glob("**/*.svg"))
            if snapshot_files:
                latest_snapshot = max(snapshot_files, key=lambda p: p.stat().st_mtime)
                target_path = screenshots_dir / f"{filename_prefix}.svg"
                
                import shutil
                shutil.copy2(latest_snapshot, target_path)
                print(f"Screenshot saved: {target_path}")
```

## Key Testing Parameters

### Terminal Size Consistency

```python
# Use consistent terminal size across all tests
terminal_size=(120, 40)  # width=120 cols, height=40 lines

# Common alternatives based on use case:
terminal_size=(80, 24)   # Standard/minimal
terminal_size=(100, 30)  # Medium development
terminal_size=(140, 50)  # Large/presentation
```

**Insight**: Consistent terminal size is critical for reproducible screenshots across different development environments.

### Timing and System Validation

```python
# Pattern for apps with startup system checks
press=["wait:3000"]  # Wait 3 seconds for Docker/Python/system validation

# Pattern for screen navigation  
press=["wait:3000", "enter", "wait:1000"]  # Startup → Navigate → Wait for load

# Pattern for complex interactions
press=["wait:2000", "tab", "tab", "space", "wait:1000"]  # Wait → Navigate → Action → Wait
```

**Critical Insight**: Many GUI apps perform system validation on startup (Docker availability, version checks, etc.). Always include sufficient wait time before capturing screenshots.

## Running Tests - The Workflow

### Initial Setup (First Time)

```bash
# 1. First run will FAIL - this is expected
pixi run -e dev pytest tests/autotest/test_gui_screenshots.py::TestGUIScreenshots::test_sc0_startup_screen -v

# 2. Update snapshots to accept the initial capture
pixi run -e dev pytest tests/autotest/test_gui_screenshots.py::TestGUIScreenshots::test_sc0_startup_screen --snapshot-update

# 3. Repeat for other tests
pixi run -e dev pytest tests/autotest/test_gui_screenshots.py::TestGUIScreenshots::test_sc1_project_setup_screen --snapshot-update
```

### Ongoing Testing

```bash
# Run all GUI tests
pixi run -e dev pytest tests/autotest/test_gui_screenshots.py -v

# Run specific test
pixi run -e dev pytest tests/autotest/test_gui_screenshots.py::TestGUIScreenshots::test_sc0_startup_screen -v

# Update after intentional changes
pixi run -e dev pytest tests/autotest/test_gui_screenshots.py --snapshot-update
```

## Common Issues and Solutions

### 1. File Path Problems

**Problem**: `FileNotFoundError: test_app.py not found`

**Solutions**:
```python
# Wrong: Using relative paths or temporary files
test_app_path = Path("tmp/test_app.py")  # Fails

# Right: Using permanent file with proper path resolution
test_app_path = Path(__file__).parent / "gui_test_app.py"  # Works
assert test_app_path.exists(), f"Test app not found: {test_app_path}"
```

### 2. Import Errors in Test Wrapper

**Problem**: `ModuleNotFoundError: No module named 'your_package'`

**Solutions**:
```python
# In gui_test_app.py - ensure robust path setup
import sys
from pathlib import Path

# Add multiple potential import paths
repo_root = Path(__file__).parent.parent.parent
sys.path.insert(0, str(repo_root / "src"))
sys.path.insert(0, str(repo_root))

# Verify import works
try:
    from your_package.gui.app import YourApp
except ImportError as e:
    print(f"Import error: {e}")
    print(f"Python path: {sys.path}")
    raise
```

### 3. Timing Issues

**Problem**: Screenshots are inconsistent or show loading states

**Solutions**:
```python
# Too short - may capture loading screen
press=["wait:1000"]  # Often not enough

# Better - allow time for system validation
press=["wait:3000"]  # Usually sufficient for most apps

# For slow systems or complex validation
press=["wait:5000"]  # More generous timing

# For multi-step flows
press=["wait:3000", "enter", "wait:2000"]  # Wait before and after navigation
```

### 4. Test Environment Consistency

**Problem**: Tests work locally but fail in CI/CD

**Solutions**:
```bash
# Use consistent environment
pixi run -e dev pytest tests/autotest/test_gui_screenshots.py -v

# Avoid system Python
python -m pytest tests/autotest/test_gui_screenshots.py  # May fail

# Check environment in CI
pixi run -e dev python -c "import sys; print(sys.path)"
```

## Advanced Patterns

### Testing Multiple Screen Flows

```python
def test_complete_user_workflow(self, snap_compare: Any) -> None:
    """Test complete user workflow across multiple screens."""
    test_app_path = Path(__file__).parent / "gui_test_app.py"
    
    # Test each major step in user flow
    test_scenarios = [
        ("startup", ["wait:3000"]),
        ("project-setup", ["wait:3000", "enter", "wait:1000"]),
        ("wizard-entry", ["wait:3000", "enter", "wait:1000", "enter", "wait:1000"]),
    ]
    
    for scenario_name, key_sequence in test_scenarios:
        assert snap_compare(
            str(test_app_path),
            terminal_size=(120, 40),
            press=key_sequence
        )
        self._copy_snapshot_to_screenshots(f"flow-{scenario_name}")
```

### Error State Testing

```python
def test_error_scenarios(self, snap_compare: Any) -> None:
    """Test how GUI handles error conditions."""
    test_app_path = Path(__file__).parent / "gui_test_app.py"
    
    # Trigger error condition (example: invalid input)
    assert snap_compare(
        str(test_app_path),
        terminal_size=(120, 40),
        press=["wait:2000", "tab", "invalid_input", "enter", "wait:1000"]
    )
    
    self._copy_snapshot_to_screenshots("error-invalid-input")
```

### Parameterized Testing

```python
@pytest.mark.parametrize("screen_name,key_sequence", [
    ("startup", ["wait:3000"]),
    ("project-setup", ["wait:3000", "enter", "wait:1000"]),
    ("configuration", ["wait:3000", "enter", "wait:1000", "enter", "wait:1000"]),
])
def test_all_screens(self, snap_compare: Any, screen_name: str, key_sequence: list) -> None:
    """Test all screens with parameterized key sequences."""
    test_app_path = Path(__file__).parent / "gui_test_app.py"
    
    assert snap_compare(
        str(test_app_path),
        terminal_size=(120, 40),
        press=key_sequence
    )
    
    self._copy_snapshot_to_screenshots(f"param-{screen_name}")
```

## Output Organization and Management

### Automated File Organization

```python
def _copy_snapshot_to_screenshots(self, filename_prefix: str) -> None:
    """Enhanced copy with better organization."""
    snapshots_dir = Path("tests/__snapshots__")
    screenshots_dir = Path("tmp/output/gui-screenshots")
    
    # Create organized subdirectories
    by_date = screenshots_dir / datetime.now().strftime("%Y-%m-%d")
    by_feature = screenshots_dir / "features"
    
    if snapshots_dir.exists():
        snapshot_files = list(snapshots_dir.glob("**/*.svg"))
        if snapshot_files:
            latest_snapshot = max(snapshot_files, key=lambda p: p.stat().st_mtime)
            
            # Copy to multiple locations
            main_target = screenshots_dir / f"{filename_prefix}.svg"
            dated_target = by_date / f"{filename_prefix}.svg"
            
            import shutil
            shutil.copy2(latest_snapshot, main_target)
            by_date.mkdir(parents=True, exist_ok=True)
            shutil.copy2(latest_snapshot, dated_target)
            
            print(f"Screenshots saved: {main_target}, {dated_target}")
```

### Cleanup Automation

```python
@pytest.fixture(autouse=True, scope="session")
def cleanup_old_screenshots():
    """Clean up old screenshots before test session."""
    screenshots_dir = Path("tmp/output/gui-screenshots")
    if screenshots_dir.exists():
        import time
        cutoff = time.time() - (7 * 24 * 3600)  # 7 days
        
        for old_file in screenshots_dir.glob("**/*.svg"):
            if old_file.stat().st_mtime < cutoff:
                old_file.unlink()
                print(f"Cleaned up old screenshot: {old_file}")
```

## CI/CD Integration

### GitHub Actions Example

```yaml
name: GUI Screenshot Tests
on: [push, pull_request]

jobs:
  gui-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      
      - name: Setup Pixi
        uses: prefix-dev/setup-pixi@v0.4.1
        
      - name: Run GUI Screenshot Tests
        run: |
          pixi run -e dev pytest tests/autotest/test_gui_screenshots.py -v
          
      - name: Upload Screenshots
        uses: actions/upload-artifact@v3
        if: always()  # Upload even if tests fail
        with:
          name: gui-screenshots-${{ github.sha }}
          path: tmp/output/gui-screenshots/
          
      - name: Upload Test Report
        uses: actions/upload-artifact@v3
        if: failure()
        with:
          name: test-failure-report-${{ github.sha }}
          path: snapshot_report.html
```

## Documentation Integration

### Auto-Generated README

```python
# Add to test script for automatic documentation
def generate_screenshot_index():
    """Generate an index of all captured screenshots."""
    screenshots_dir = Path("tmp/output/gui-screenshots")
    readme_content = ["# GUI Screenshots\n\nAutomatically generated screenshots:\n"]
    
    for screenshot in sorted(screenshots_dir.glob("*.svg")):
        screen_name = screenshot.stem.replace("-", " ").title()
        readme_content.append(f"## {screen_name}\n")
        readme_content.append(f"![{screen_name}]({screenshot.name})\n")
    
    readme_path = screenshots_dir / "README.md"
    readme_path.write_text("\n".join(readme_content))
    print(f"Generated screenshot index: {readme_path}")

# Call after all tests complete
@pytest.fixture(autouse=True, scope="session")
def generate_docs():
    yield
    generate_screenshot_index()
```

## Best Practices Summary

1. **Use permanent test wrapper files** - Don't create temporary files
2. **Consistent terminal sizing** - Use same size across all tests
3. **Generous timing** - Allow time for system validation and loading
4. **Proper path resolution** - Use absolute paths with Path(__file__)
5. **Environment consistency** - Always use pixi dev environment
6. **Meaningful test names** - Include screen identifiers (SC-0, SC-1, etc.)
7. **Organized outputs** - Copy snapshots to well-organized directories
8. **Documentation integration** - Auto-generate visual documentation
9. **CI/CD friendly** - Design for headless execution
10. **Error handling** - Test both success and error scenarios

## Troubleshooting Checklist

When tests fail, check:

- [ ] Is `gui_test_app.py` executable standalone?
- [ ] Are import paths correct in the test wrapper?
- [ ] Is sufficient wait time included for system validation?
- [ ] Is terminal size consistent across tests?
- [ ] Are you using the pixi dev environment?
- [ ] Do the snapshot directories exist and have proper permissions?
- [ ] Are you using absolute file paths?
- [ ] Is the test app path resolved correctly?

## Real-World Results

After implementing this approach for PeiDocker GUI:

- ✅ Successfully captured SC-0 (Application Startup Screen)
- ✅ Successfully captured SC-1 (Project Directory Selection Screen)  
- ✅ Automated navigation between screens
- ✅ Consistent 120x40 terminal sizing
- ✅ Proper system validation timing (3-second delays)
- ✅ Organized output in `tmp/output/gui-screenshots/`
- ✅ Integration with pytest regression testing
- ✅ CI/CD ready headless execution

The final implementation provides reliable, automated screenshot capture that can be used for visual verification, documentation generation, and regression testing of Textual GUI applications.

## Related Files

- `tests/autotest/test_gui_screenshots.py` - Working implementation
- `tests/autotest/gui_test_app.py` - Test wrapper example
- `tests/autotest/README.md` - Project-specific documentation
- `context/hints/howto-test-textual-gui-applications-headless.md` - General headless testing guide