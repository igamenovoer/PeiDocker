"""
Utility functions for PeiDocker Web GUI.

This module provides utility classes for project management, file operations,
and integration with the existing PeiDocker CLI commands.
"""

import asyncio
import subprocess
import tempfile
import zipfile
import shutil
from pathlib import Path
from typing import Optional, Dict, Any, List
import yaml
import omegaconf as oc
from omegaconf import DictConfig
import copy

from pei_docker.config_processor import PeiConfigProcessor
from pei_docker.user_config import UserConfig
from pei_docker.webgui.legacy_models import ConfigurationState

class ProjectManager:
    """Manages PeiDocker project operations."""
    
    def __init__(self) -> None:
        self._cli_available: Optional[bool] = None
    
    async def check_cli_availability(self) -> bool:
        """Check if pei-docker-cli is available."""
        if self._cli_available is not None:
            return self._cli_available
        
        try:
            process = await asyncio.create_subprocess_exec(
                'pei-docker-cli', '--version',
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )
            
            stdout, stderr = await process.communicate()
            self._cli_available = process.returncode == 0
            return self._cli_available
            
        except FileNotFoundError:
            self._cli_available = False
            return False
        except Exception:
            self._cli_available = False
            return False
    
    async def create_project(self, project_dir: Path) -> bool:
        """Create a new PeiDocker project using CLI or fallback."""
        try:
            # Check if directory exists and is empty
            if project_dir.exists():
                if any(project_dir.iterdir()):
                    raise ValueError(f"Directory {project_dir} is not empty")
            else:
                project_dir.mkdir(parents=True, exist_ok=True)
            
            # Check if CLI is available
            if await self.check_cli_availability():
                # Use CLI
                return await self._create_project_with_cli(project_dir)
            else:
                # Use fallback method
                return await self._create_project_fallback(project_dir)
                
        except Exception as e:
            print(f"Error creating project: {e}")
            return False
    
    async def _create_project_with_cli(self, project_dir: Path) -> bool:
        """Create project using pei-docker-cli."""
        try:
            cmd = ['pei-docker-cli', 'create', '-p', str(project_dir)]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=project_dir.parent
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                return True
            else:
                print(f"CLI project creation failed: {stderr.decode()}")
                # Try fallback method
                return await self._create_project_fallback(project_dir)
                
        except Exception as e:
            print(f"Error with CLI project creation: {e}")
            # Try fallback method
            return await self._create_project_fallback(project_dir)
    
    async def _create_project_fallback(self, project_dir: Path) -> bool:
        """Create basic project structure without CLI."""
        try:
            # Create basic project structure
            project_dir.mkdir(parents=True, exist_ok=True)
            
            # Create basic user_config.yml
            config_file = project_dir / 'user_config.yml'
            basic_config = {
                'stage_1': {
                    'image': {
                        'base': 'ubuntu:22.04',
                        'output': f'{project_dir.name}:stage-1'
                    }
                },
                'stage_2': {
                    'image': {
                        'output': f'{project_dir.name}:stage-2'
                    }
                }
            }
            
            with open(config_file, 'w') as f:
                yaml.dump(basic_config, f, default_flow_style=False, sort_keys=False, indent=2)
            
            # Create basic directory structure
            (project_dir / 'stage-1' / 'custom').mkdir(parents=True, exist_ok=True)
            (project_dir / 'stage-2' / 'custom').mkdir(parents=True, exist_ok=True)
            (project_dir / 'installation').mkdir(parents=True, exist_ok=True)
            
            # Create placeholder Dockerfiles
            stage1_dockerfile = project_dir / 'stage-1.Dockerfile'
            stage1_dockerfile.write_text("# PeiDocker Stage-1 Dockerfile\n# This will be generated by pei-docker-cli configure\n")
            
            stage2_dockerfile = project_dir / 'stage-2.Dockerfile' 
            stage2_dockerfile.write_text("# PeiDocker Stage-2 Dockerfile\n# This will be generated by pei-docker-cli configure\n")
            
            return True
            
        except Exception as e:
            print(f"Error in fallback project creation: {e}")
            return False
    
    async def configure_project(self, project_dir: Path) -> bool:
        """Configure a PeiDocker project using CLI or fallback."""
        try:
            # Check if CLI is available
            if await self.check_cli_availability():
                return await self._configure_project_with_cli(project_dir)
            else:
                return await self._configure_project_fallback(project_dir)
                
        except Exception as e:
            print(f"Error configuring project: {e}")
            return False
    
    async def _configure_project_with_cli(self, project_dir: Path) -> bool:
        """Configure project using pei-docker-cli."""
        try:
            cmd = ['pei-docker-cli', 'configure', '-p', str(project_dir)]
            
            process = await asyncio.create_subprocess_exec(
                *cmd,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE,
                cwd=project_dir
            )
            
            stdout, stderr = await process.communicate()
            
            if process.returncode == 0:
                return True
            else:
                print(f"CLI project configuration failed: {stderr.decode()}")
                # Try fallback method
                return await self._configure_project_fallback(project_dir)
                
        except Exception as e:
            print(f"Error with CLI project configuration: {e}")
            # Try fallback method
            return await self._configure_project_fallback(project_dir)
    
    async def _configure_project_fallback(self, project_dir: Path) -> bool:
        """Configure project without CLI - basic validation and setup."""
        try:
            # Check if user_config.yml exists
            config_file = project_dir / 'user_config.yml'
            if not config_file.exists():
                print("No user_config.yml found - cannot configure project")
                return False
            
            # Validate the configuration file is valid YAML
            with open(config_file, 'r') as f:
                try:
                    yaml.safe_load(f)
                except yaml.YAMLError as e:
                    print(f"Invalid YAML in user_config.yml: {e}")
                    return False
            
            # Update Dockerfile placeholders with basic content
            stage1_dockerfile = project_dir / 'stage-1.Dockerfile'
            if stage1_dockerfile.exists():
                # Read current config to get base image
                with open(config_file, 'r') as f:
                    config = yaml.safe_load(f) or {}
                
                base_image = config.get('stage_1', {}).get('image', {}).get('base', 'ubuntu:22.04')
                
                basic_dockerfile_content = f'''# PeiDocker Stage-1 Dockerfile (Fallback Mode)
FROM {base_image}

# Basic setup - full configuration requires pei-docker-cli
RUN apt-get update && apt-get install -y \\
    curl \\
    wget \\
    vim \\
    && rm -rf /var/lib/apt/lists/*

# Note: This is a fallback Dockerfile. 
# Install pei-docker-cli and run 'pei-docker-cli configure' for full functionality.
'''
                
                stage1_dockerfile.write_text(basic_dockerfile_content)
            
            # Create basic docker-compose.yml
            compose_file = project_dir / 'docker-compose.yml'
            if not compose_file.exists():
                compose_content = f'''# PeiDocker docker-compose.yml (Fallback Mode)
version: '3.8'

services:
  stage-1:
    build:
      context: .
      dockerfile: stage-1.Dockerfile
    image: {project_dir.name}:stage-1
    
  stage-2:
    build:
      context: .
      dockerfile: stage-2.Dockerfile
    image: {project_dir.name}:stage-2
    depends_on:
      - stage-1

# Note: This is a basic docker-compose.yml. 
# Install pei-docker-cli and run 'pei-docker-cli configure' for full functionality.
'''
                compose_file.write_text(compose_content)
            
            return True
            
        except Exception as e:
            print(f"Error in fallback project configuration: {e}")
            return False
    
    def validate_project_directory(self, project_dir: Path) -> bool:
        """Validate if a directory is a valid PeiDocker project."""
        if not project_dir.exists():
            return False
        
        # Check for required files/directories
        required_items = [
            'user_config.yml',
            'installation',
            'stage-1.Dockerfile',
            'stage-2.Dockerfile'
        ]
        
        for item in required_items:
            if not (project_dir / item).exists():
                return False
        
        return True

class FileOperations:
    """Handles file operations for configuration and project management."""
    
    async def save_configuration(self, project_dir: Path, config_state: ConfigurationState) -> bool:
        """Save configuration to user_config.yml and script files."""
        try:
            # Create user_config.yml from configuration state with deep copy
            config_data = {
                'stage_1': copy.deepcopy(dict(config_state.stage_1)),
                'stage_2': copy.deepcopy(dict(config_state.stage_2))
            }
            
            # Process inline scripts before saving
            await self._process_and_save_inline_scripts(project_dir, config_data)
            
            # Remove _inline_scripts metadata from config data
            for stage in ['stage_1', 'stage_2']:
                if stage in config_data and '_inline_scripts' in config_data[stage]:
                    del config_data[stage]['_inline_scripts']
            
            # Remove empty sections to keep YAML clean
            config_data = {k: v for k, v in config_data.items() if v}
            for stage_dict in config_data.values():
                if isinstance(stage_dict, dict):
                    # Remove empty nested dictionaries
                    for key, value in list(stage_dict.items()):
                        if isinstance(value, dict) and not value:
                            del stage_dict[key]
                        elif isinstance(value, list) and not value:
                            del stage_dict[key]
            
            config_file = project_dir / 'user_config.yml'
            
            # Create backup of existing config
            if config_file.exists():
                backup_file = project_dir / 'user_config.yml.backup'
                shutil.copy2(config_file, backup_file)
            
            # Use OmegaConf to save YAML without anchors
            config = oc.OmegaConf.create(config_data)
            yaml_str = oc.OmegaConf.to_yaml(config)
            
            with open(config_file, 'w') as f:
                f.write(yaml_str)
            
            # Mark configuration as saved
            from datetime import datetime
            config_state.modified = False
            config_state.last_saved = datetime.now().strftime("%H:%M:%S")
            
            return True
            
        except Exception as e:
            print(f"Error saving configuration: {e}")
            return False
    
    async def load_configuration(self, project_dir: Path, config_state: ConfigurationState) -> bool:
        """Load configuration from user_config.yml into the provided config_state."""
        try:
            config_file = project_dir / 'user_config.yml'
            
            if not config_file.exists():
                # Keep default configuration
                return True
            
            with open(config_file, 'r') as f:
                config_data = yaml.safe_load(f) or {}
            
            # Update the provided config_state
            config_state.stage_1.clear()
            config_state.stage_1.update(config_data.get('stage_1', {}))
            config_state.stage_2.clear()
            config_state.stage_2.update(config_data.get('stage_2', {}))
            
            # Mark as not modified since we just loaded from file
            config_state.modified = False
            config_state.last_saved = "Just loaded"
            
            return True
            
        except Exception as e:
            print(f"Error loading configuration: {e}")
            return False
    
    async def _process_and_save_inline_scripts(self, project_dir: Path, config_data: dict) -> None:
        """Process and save inline scripts from the Scripts tab.
        
        The Scripts tab stores inline script metadata in _inline_scripts.
        This method extracts that data, saves the scripts to files, and ensures
        the config only contains file paths (not inline content).
        """
        try:
            installation_dir = project_dir / 'installation'
            
            for stage_name, stage_config in [('stage_1', config_data.get('stage_1', {})), 
                                            ('stage_2', config_data.get('stage_2', {}))]:
                if not stage_config or '_inline_scripts' not in stage_config:
                    continue
                
                inline_scripts = stage_config.get('_inline_scripts', [])
                
                for script_info in inline_scripts:
                    script_path = script_info.get('path', '')
                    script_content = script_info.get('content', '')
                    
                    if script_path and script_content:
                        # Create full path for the script file
                        full_path = installation_dir / script_path
                        
                        # Create directory if it doesn't exist
                        full_path.parent.mkdir(parents=True, exist_ok=True)
                        
                        # Write script content
                        with open(full_path, 'w') as f:
                            # Ensure script has proper shebang if missing
                            if not script_content.startswith('#!'):
                                f.write('#!/bin/bash\n')
                            f.write(script_content)
                        
                        # Make script executable
                        full_path.chmod(0o755)
                        
        except Exception as e:
            print(f"Error processing inline scripts: {e}")
    
    async def create_project_zip(self, project_dir: Path) -> Optional[Path]:
        """Create a ZIP archive of the project directory."""
        try:
            # Create temporary ZIP file
            temp_dir = Path(tempfile.gettempdir())
            zip_path = temp_dir / f"{project_dir.name}.zip"
            
            with zipfile.ZipFile(zip_path, 'w', zipfile.ZIP_DEFLATED) as zipf:
                for file_path in project_dir.rglob('*'):
                    if file_path.is_file():
                        arcname = file_path.relative_to(project_dir)
                        zipf.write(file_path, arcname)
            
            return zip_path
            
        except Exception as e:
            print(f"Error creating project ZIP: {e}")
            return None

class ValidationManager:
    """Manages configuration validation."""
    
    def validate_project_name(self, name: str) -> tuple[bool, Optional[str]]:
        """Validate project name."""
        if not name:
            return False, "Project name is required"
        
        if not name.replace('-', '').replace('_', '').isalnum():
            return False, "Project name can only contain letters, numbers, hyphens, and underscores"
        
        return True, None
    
    def validate_port(self, port: str) -> tuple[bool, Optional[str]]:
        """Validate port number."""
        try:
            port_num = int(port)
            if not (1 <= port_num <= 65535):
                return False, "Port must be between 1 and 65535"
            return True, None
        except ValueError:
            return False, "Port must be a valid number"
    
    def validate_port_range(self, port_range: str) -> tuple[bool, Optional[str]]:
        """Validate port range (e.g., 9090-9099)."""
        if '-' not in port_range:
            return self.validate_port(port_range)
        
        try:
            start, end = port_range.split('-', 1)
            start_num = int(start.strip())
            end_num = int(end.strip())
            
            if not (1 <= start_num <= 65535) or not (1 <= end_num <= 65535):
                return False, "Port numbers must be between 1 and 65535"
            
            if start_num >= end_num:
                return False, "Start port must be less than end port"
            
            if end_num - start_num > 1000:
                return False, "Port range too large (max 1000 ports)"
            
            return True, None
            
        except ValueError:
            return False, "Invalid port range format"
    
    def validate_environment_var_name(self, name: str) -> tuple[bool, Optional[str]]:
        """Validate environment variable name."""
        if not name:
            return False, "Environment variable name is required"
        
        if not name.isidentifier():
            return False, "Environment variable name must be a valid identifier"
        
        return True, None
    
    def validate_ssh_username(self, username: str) -> tuple[bool, Optional[str]]:
        """Validate SSH username."""
        if not username:
            return False, "SSH username is required"
        
        if not username.replace('-', '').replace('_', '').isalnum():
            return False, "Username can only contain letters, numbers, hyphens, and underscores"
        
        if len(username) > 32:
            return False, "Username must be 32 characters or less"
        
        return True, None
    
    def validate_ssh_password(self, password: str) -> tuple[bool, Optional[str]]:
        """Validate SSH password."""
        if not password:
            return False, "SSH password is required"
        
        if len(password) < 6:
            return False, "Password must be at least 6 characters long"
        
        return True, None
    
    def validate_proxy_url(self, url: str) -> tuple[bool, Optional[str]]:
        """Validate proxy URL."""
        if not url:
            return False, "Proxy URL is required"
        
        # Basic URL validation
        if not ('://' in url or ':' in url):
            return False, "Proxy URL must include host and port (e.g., host:port or http://host:port)"
        
        return True, None
    
    def validate_volume_name(self, name: str) -> tuple[bool, Optional[str]]:
        """Validate Docker volume name."""
        if not name:
            return False, "Volume name is required"
        
        # Docker volume name rules
        if not name.replace('-', '').replace('_', '').replace('.', '').isalnum():
            return False, "Volume name can only contain letters, numbers, hyphens, underscores, and periods"
        
        if len(name) > 63:
            return False, "Volume name must be 63 characters or less"
        
        return True, None
    
    def validate_script_path(self, path: str, stage: str) -> tuple[bool, Optional[str]]:
        """Validate script path based on stage rules."""
        if not path:
            return False, "Script path is required"
        
        if stage == 'stage1':
            if not path.startswith('stage-1/'):
                return False, "Stage-1 scripts can only reference paths starting with 'stage-1/'"
        elif stage == 'stage2':
            if not (path.startswith('stage-1/') or path.startswith('stage-2/')):
                return False, "Stage-2 scripts can reference paths starting with 'stage-1/' or 'stage-2/'"
        
        return True, None
    
    def validate_gpu_memory(self, memory: str) -> tuple[bool, Optional[str]]:
        """Validate GPU memory limit format."""
        if not memory:
            return True, None  # Optional field
        
        # Check if it ends with valid units
        valid_units = ['GB', 'MB', 'KB', 'G', 'M', 'K']
        if not any(memory.upper().endswith(unit) for unit in valid_units):
            return False, "GPU memory limit should specify units (e.g., '4GB', '512MB')"
        
        # Extract numeric part
        numeric_part = memory[:-1] if memory[-1].isalpha() else memory[:-2]
        try:
            float(numeric_part)
            return True, None
        except ValueError:
            return False, "GPU memory limit must be a valid number with units"
    
    def validate_path(self, path: str, must_exist: bool = False) -> tuple[bool, Optional[str]]:
        """Validate file/directory path."""
        if not path.strip():
            return False, "Path cannot be empty"
        
        try:
            path_obj = Path(path)
            
            if must_exist and not path_obj.exists():
                return False, f"Path does not exist: {path}"
            
            return True, None
            
        except Exception as e:
            return False, f"Invalid path: {str(e)}"
    
    def validate_container_path(self, path: str) -> tuple[bool, Optional[str]]:
        """Validate container path (must be absolute)."""
        if not path:
            return False, "Container path is required"
        
        if not path.startswith('/'):
            return False, "Container path must be an absolute path (start with /)"
        
        return True, None
    
    def validate_host_path(self, path: str) -> tuple[bool, Optional[str]]:
        """Validate host path (must be absolute)."""
        if not path:
            return False, "Host path is required"
        
        if not path.startswith('/'):
            return False, "Host path must be an absolute path (start with /)"
        
        return True, None


class RealTimeValidator:
    """Real-time validation system for the GUI."""
    
    def __init__(self, app_data: Any, validation_manager: ValidationManager) -> None:
        self.app_data = app_data
        self.validator = validation_manager
    
    def validate_all_tabs(self) -> Dict[str, List[str]]:
        """Validate all tabs and return errors by tab name."""
        all_errors = {}
        
        # Project tab validation
        project_errors = self._validate_project_tab()
        if project_errors:
            all_errors['project'] = project_errors
        
        # SSH tab validation
        ssh_errors = self._validate_ssh_tab()
        if ssh_errors:
            all_errors['ssh'] = ssh_errors
        
        # Network tab validation
        network_errors = self._validate_network_tab()
        if network_errors:
            all_errors['network'] = network_errors
        
        # Environment tab validation
        env_errors = self._validate_environment_tab()
        if env_errors:
            all_errors['environment'] = env_errors
        
        # Storage tab validation
        storage_errors = self._validate_storage_tab()
        if storage_errors:
            all_errors['storage'] = storage_errors
        
        # Scripts tab validation
        scripts_errors = self._validate_scripts_tab()
        if scripts_errors:
            all_errors['scripts'] = scripts_errors
        
        return all_errors
    
    def _validate_project_tab(self) -> List[str]:
        """Validate project tab configuration."""
        errors = []
        
        # Validate project name
        if self.app_data.project.name:
            is_valid, error = self.validator.validate_project_name(self.app_data.project.name)
            if not is_valid and error is not None:
                errors.append(error)
        
        return errors
    
    def _validate_ssh_tab(self) -> List[str]:
        """Validate SSH tab configuration."""
        errors = []
        ssh_config = self.app_data.config.stage_1.get('ssh', {})
        
        if ssh_config.get('enabled', False):
            # Validate ports
            port = ssh_config.get('port', 22)
            host_port = ssh_config.get('host_port', 2222)
            
            is_valid, error = self.validator.validate_port(str(port))
            if not is_valid:
                errors.append(f"SSH container port: {error}")
            
            is_valid, error = self.validator.validate_port(str(host_port))
            if not is_valid:
                errors.append(f"SSH host port: {error}")
            
            # Validate users
            users = ssh_config.get('users', [])
            for i, user in enumerate(users):
                username = user.get('username', '')
                password = user.get('password', '')
                
                if username:
                    is_valid, error = self.validator.validate_ssh_username(username)
                    if not is_valid:
                        errors.append(f"SSH user {i+1} username: {error}")
                
                if password:
                    is_valid, error = self.validator.validate_ssh_password(password)
                    if not is_valid:
                        errors.append(f"SSH user {i+1} password: {error}")
        
        return errors
    
    def _validate_network_tab(self) -> List[str]:
        """Validate network tab configuration."""
        errors = []
        
        # Validate proxy
        proxy_config = self.app_data.config.stage_1.get('proxy', {})
        if proxy_config.get('enabled', False):
            proxy_url = proxy_config.get('url', '')
            if proxy_url:
                is_valid, error = self.validator.validate_proxy_url(proxy_url)
                if not is_valid:
                    errors.append(f"Proxy URL: {error}")
        
        # Validate port mappings
        ports = self.app_data.config.stage_1.get('ports', [])
        for i, port_mapping in enumerate(ports):
            if ':' in port_mapping:
                host_port, container_port = port_mapping.split(':', 1)
                
                is_valid, error = self.validator.validate_port_range(host_port)
                if not is_valid:
                    errors.append(f"Port mapping {i+1} host port: {error}")
                
                is_valid, error = self.validator.validate_port_range(container_port)
                if not is_valid:
                    errors.append(f"Port mapping {i+1} container port: {error}")
        
        return errors
    
    def _validate_environment_tab(self) -> List[str]:
        """Validate environment tab configuration."""
        errors = []
        
        # Validate environment variables
        env_config = self.app_data.config.stage_1.get('environment', [])
        
        # Handle both list and dict formats
        variables = {}
        if isinstance(env_config, list):
            # Parse list format ['KEY=VALUE', ...]
            for env_str in env_config:
                if '=' in env_str:
                    key, value = env_str.split('=', 1)
                    variables[key.strip()] = value.strip()
        elif isinstance(env_config, dict):
            variables = env_config.get('variables', {})
        
        for name, value in variables.items():
            is_valid, error = self.validator.validate_environment_var_name(name)
            if not is_valid:
                errors.append(f"Environment variable '{name}': {error}")
        
        # Validate GPU configuration
        device_config = self.app_data.config.stage_1.get('device', {})
        if device_config.get('type') == 'gpu':
            gpu_config = device_config.get('gpu', {})
            memory_limit = gpu_config.get('memory', '')
            
            if memory_limit:
                is_valid, error = self.validator.validate_gpu_memory(memory_limit)
                if not is_valid:
                    errors.append(f"GPU memory limit: {error}")
        
        return errors
    
    def _validate_storage_tab(self) -> List[str]:
        """Validate storage tab configuration."""
        errors = []
        
        # Validate Stage-2 dynamic storage
        storage_config = self.app_data.config.stage_2.get('storage', {})
        for storage_type, config in storage_config.items():
            if config.get('type') == 'host':
                host_path = config.get('host_path', '')
                if host_path:
                    is_valid, error = self.validator.validate_host_path(host_path)
                    if not is_valid:
                        errors.append(f"{storage_type.title()} storage host path: {error}")
            
            elif config.get('type') == 'manual-volume':
                volume_name = config.get('volume_name', '')
                if volume_name:
                    is_valid, error = self.validator.validate_volume_name(volume_name)
                    if not is_valid:
                        errors.append(f"{storage_type.title()} storage volume name: {error}")
        
        # Validate mounts
        for stage_name in ['stage_1', 'stage_2']:
            mounts = self.app_data.config.__dict__[stage_name].get('mounts', [])
            for i, mount in enumerate(mounts):
                container_path = mount.get('container_path', '')
                mount_type = mount.get('type', '')
                
                if container_path:
                    is_valid, error = self.validator.validate_container_path(container_path)
                    if not is_valid:
                        errors.append(f"{stage_name.replace('_', '-').title()} mount {i+1} container path: {error}")
                
                if mount_type == 'host':
                    host_path = mount.get('host_path', '')
                    if host_path:
                        is_valid, error = self.validator.validate_host_path(host_path)
                        if not is_valid:
                            errors.append(f"{stage_name.replace('_', '-').title()} mount {i+1} host path: {error}")
                
                elif mount_type == 'manual-volume':
                    volume_name = mount.get('volume_name', '')
                    if volume_name:
                        is_valid, error = self.validator.validate_volume_name(volume_name)
                        if not is_valid:
                            errors.append(f"{stage_name.replace('_', '-').title()} mount {i+1} volume name: {error}")
        
        return errors
    
    def _validate_scripts_tab(self) -> List[str]:
        """Validate scripts tab configuration."""
        errors = []
        
        for stage_name in ['stage_1', 'stage_2']:
            scripts_config = self.app_data.config.__dict__[stage_name].get('scripts', {})
            stage_display = stage_name.replace('_', '-')
            
            # Validate entry point
            if 'entry_point' in scripts_config:
                entry_point = scripts_config['entry_point']
                if entry_point.get('type') == 'file':
                    path = entry_point.get('path', '')
                    if path:
                        is_valid, error = self.validator.validate_script_path(path, stage_name.split('_')[1])
                        if not is_valid:
                            errors.append(f"{stage_display.title()} entry point: {error}")
            
            # Validate lifecycle scripts
            for lifecycle_type in ['on_build', 'on_first_run', 'on_every_run', 'on_user_login']:
                if lifecycle_type in scripts_config:
                    scripts = scripts_config[lifecycle_type]
                    for i, script in enumerate(scripts):
                        if script.get('type') == 'file':
                            path = script.get('path', '')
                            if path:
                                is_valid, error = self.validator.validate_script_path(path, stage_name.split('_')[1])
                                if not is_valid:
                                    errors.append(f"{stage_display.title()} {lifecycle_type} script {i+1}: {error}")
        
        return errors